(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/encoderWorker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./src/encoderWorker.js":
/*!******************************!*\
  !*** ./src/encoderWorker.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
<<<<<<< HEAD
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nconst OggOpusEncoder = function( config, Module ){\n\n  if ( !Module ) {\n    throw new Error('Module with exports required to initialize an encoder instance');\n  }\n\n  this.config = Object.assign({ \n    bufferLength: 4096, // Define size of incoming buffer\n    encoderApplication: 2049, // 2048 = Voice (Lower fidelity)\n                              // 2049 = Full Band Audio (Highest fidelity)\n                              // 2051 = Restricted Low Delay (Lowest latency)\n    encoderFrameSize: 20, // Specified in ms.\n    encoderSampleRate: 48000, // Desired encoding sample rate. Audio will be resampled\n    maxFramesPerPage: 40, // Tradeoff latency with overhead\n    numberOfChannels: 1,\n    originalSampleRate: 44100,\n    resampleQuality: 3, // Value between 0 and 10 inclusive. 10 being highest quality.\n    serial: Math.floor(Math.random() * 4294967296)\n  }, config );\n\n  this._opus_encoder_create = Module._opus_encoder_create;\n  this._opus_encoder_destroy = Module._opus_encoder_destroy;\n  this._opus_encoder_ctl = Module._opus_encoder_ctl;\n  this._speex_resampler_process_interleaved_float = Module._speex_resampler_process_interleaved_float;\n  this._speex_resampler_init = Module._speex_resampler_init;\n  this._speex_resampler_destroy = Module._speex_resampler_destroy;\n  this._opus_encode_float = Module._opus_encode_float;\n  this._free = Module._free;\n  this._malloc = Module._malloc;\n  this.HEAPU8 = Module.HEAPU8;\n  this.HEAP32 = Module.HEAP32;\n  this.HEAPF32 = Module.HEAPF32;\n\n  this.pageIndex = 0;\n  this.granulePosition = 0;\n  this.segmentData = new Uint8Array( 65025 ); // Maximum length of oggOpus data\n  this.segmentDataIndex = 0;\n  this.segmentTable = new Uint8Array( 255 ); // Maximum data segments\n  this.segmentTableIndex = 0;\n  this.framesInPage = 0;\n\n  this.initChecksumTable();\n  this.initCodec();\n  this.initResampler();\n\n  if ( this.config.numberOfChannels === 1 ) {\n    this.interleave = function( buffers ) { return buffers[0]; };\n  }\n  else {\n    this.interleavedBuffers = new Float32Array( this.config.bufferLength * this.config.numberOfChannels );\n  }\n\n};\n\nOggOpusEncoder.prototype.encode = function( buffers ) {\n  var samples = this.interleave( buffers );\n  var sampleIndex = 0;\n  var exportPages = [];\n\n  while ( sampleIndex < samples.length ) {\n\n    var lengthToCopy = Math.min( this.resampleBufferLength - this.resampleBufferIndex, samples.length - sampleIndex );\n    this.resampleBuffer.set( samples.subarray( sampleIndex, sampleIndex+lengthToCopy ), this.resampleBufferIndex );\n    sampleIndex += lengthToCopy;\n    this.resampleBufferIndex += lengthToCopy;\n\n    if ( this.resampleBufferIndex === this.resampleBufferLength ) {\n      this._speex_resampler_process_interleaved_float( this.resampler, this.resampleBufferPointer, this.resampleSamplesPerChannelPointer, this.encoderBufferPointer, this.encoderSamplesPerChannelPointer );\n      var packetLength = this._opus_encode_float( this.encoder, this.encoderBufferPointer, this.encoderSamplesPerChannel, this.encoderOutputPointer, this.encoderOutputMaxLength );\n      exportPages.concat(this.segmentPacket( packetLength ));\n      this.resampleBufferIndex = 0;\n\n      this.framesInPage++;\n      if ( this.framesInPage >= this.config.maxFramesPerPage ) {\n        exportPages.push( this.generatePage() );\n      }\n    }\n  }\n\n  return exportPages;\n};\n\nOggOpusEncoder.prototype.destroy = function() {\n  if ( this.encoder ) {\n    this._free(this.encoderSamplesPerChannelPointer);\n    delete this.encoderSamplesPerChannelPointer;\n    this._free(this.encoderBufferPointer);\n    delete this.encoderBufferPointer;\n    this._free(this.encoderOutputPointer);\n    delete this.encoderOutputPointer;\n    this._free(this.resampleSamplesPerChannelPointer);\n    delete this.resampleSamplesPerChannelPointer;\n    this._free(this.resampleBufferPointer);\n    delete this.resampleBufferPointer;\n    this._speex_resampler_destroy(this.resampler);\n    delete this.resampler;\n    this._opus_encoder_destroy(this.encoder);\n    delete this.encoder;\n  }\n};\n\nOggOpusEncoder.prototype.flush = function() {\n  var exportPage;\n  if ( this.framesInPage ) {\n    exportPage = this.generatePage();\n  }\n  // discard any pending data in resample buffer (only a few ms worth)\n  this.resampleBufferIndex = 0;\n  return exportPage;\n};\n\nOggOpusEncoder.prototype.encodeFinalFrame = function() {\n  if ( this.resampleBufferIndex > 0 ) {\n    var finalFrameBuffers = [];\n    for ( var i = 0; i < this.config.numberOfChannels; ++i ) {\n      finalFrameBuffers.push( new Float32Array( this.config.bufferLength - (this.resampleBufferIndex / this.config.numberOfChannels) ));\n    }\n    this.encode( finalFrameBuffers );\n  }\n  this.headerType += 4;\n  return this.generatePage();\n};\n\nOggOpusEncoder.prototype.getChecksum = function( data ){\n  var checksum = 0;\n  for ( var i = 0; i < data.length; i++ ) {\n    checksum = (checksum << 8) ^ this.checksumTable[ ((checksum>>>24) & 0xff) ^ data[i] ];\n  }\n  return checksum >>> 0;\n};\n\nOggOpusEncoder.prototype.generateCommentPage = function(){\n  var segmentDataView = new DataView( this.segmentData.buffer );\n  segmentDataView.setUint32( 0, 1937076303, true ) // Magic Signature 'Opus'\n  segmentDataView.setUint32( 4, 1936154964, true ) // Magic Signature 'Tags'\n  segmentDataView.setUint32( 8, 10, true ); // Vendor Length\n  segmentDataView.setUint32( 12, 1868784978, true ); // Vendor name 'Reco'\n  segmentDataView.setUint32( 16, 1919247474, true ); // Vendor name 'rder'\n  segmentDataView.setUint16( 20, 21322, true ); // Vendor name 'JS'\n  segmentDataView.setUint32( 22, 0, true ); // User Comment List Length\n  this.segmentTableIndex = 1;\n  this.segmentDataIndex = this.segmentTable[0] = 26;\n  this.headerType = 0;\n  return this.generatePage();\n};\n\nOggOpusEncoder.prototype.generateIdPage = function(){\n  var segmentDataView = new DataView( this.segmentData.buffer );\n  segmentDataView.setUint32( 0, 1937076303, true ) // Magic Signature 'Opus'\n  segmentDataView.setUint32( 4, 1684104520, true ) // Magic Signature 'Head'\n  segmentDataView.setUint8( 8, 1, true ); // Version\n  segmentDataView.setUint8( 9, this.config.numberOfChannels, true ); // Channel count\n  segmentDataView.setUint16( 10, 3840, true ); // pre-skip (80ms)\n  segmentDataView.setUint32( 12, this.config.originalSampleRateOverride || this.config.originalSampleRate, true ); // original sample rate\n  segmentDataView.setUint16( 16, 0, true ); // output gain\n  segmentDataView.setUint8( 18, 0, true ); // channel map 0 = mono or stereo\n  this.segmentTableIndex = 1;\n  this.segmentDataIndex = this.segmentTable[0] = 19;\n  this.headerType = 2;\n  return this.generatePage();\n};\n\nOggOpusEncoder.prototype.generatePage = function(){\n  var granulePosition = ( this.lastPositiveGranulePosition === this.granulePosition) ? -1 : this.granulePosition;\n  var pageBuffer = new ArrayBuffer(  27 + this.segmentTableIndex + this.segmentDataIndex );\n  var pageBufferView = new DataView( pageBuffer );\n  var page = new Uint8Array( pageBuffer );\n\n  pageBufferView.setUint32( 0, 1399285583, true); // Capture Pattern starts all page headers 'OggS'\n  pageBufferView.setUint8( 4, 0, true ); // Version\n  pageBufferView.setUint8( 5, this.headerType, true ); // 1 = continuation, 2 = beginning of stream, 4 = end of stream\n\n  // Number of samples upto and including this page at 48000Hz, into signed 64 bit Little Endian integer\n  // Javascript Number maximum value is 53 bits or 2^53 - 1 \n  pageBufferView.setUint32( 6, granulePosition, true );\n  if (granulePosition < 0) {\n    pageBufferView.setInt32( 10, Math.ceil(granulePosition/4294967297) - 1, true );\n  }\n  else {\n    pageBufferView.setInt32( 10, Math.floor(granulePosition/4294967296), true );\n  }\n\n  pageBufferView.setUint32( 14, this.config.serial, true ); // Bitstream serial number\n  pageBufferView.setUint32( 18, this.pageIndex++, true ); // Page sequence number\n  pageBufferView.setUint8( 26, this.segmentTableIndex, true ); // Number of segments in page.\n  page.set( this.segmentTable.subarray(0, this.segmentTableIndex), 27 ); // Segment Table\n  page.set( this.segmentData.subarray(0, this.segmentDataIndex), 27 + this.segmentTableIndex ); // Segment Data\n  pageBufferView.setUint32( 22, this.getChecksum( page ), true ); // Checksum\n\n  var exportPage = { message: 'page', page: page, samplePosition: this.granulePosition };\n  this.segmentTableIndex = 0;\n  this.segmentDataIndex = 0;\n  this.framesInPage = 0;\n  if ( granulePosition > 0 ) {\n    this.lastPositiveGranulePosition = granulePosition;\n  }\n\n  return exportPage;\n};\n\nOggOpusEncoder.prototype.initChecksumTable = function(){\n  this.checksumTable = [];\n  for ( var i = 0; i < 256; i++ ) {\n    var r = i << 24;\n    for ( var j = 0; j < 8; j++ ) {\n      r = ((r & 0x80000000) != 0) ? ((r << 1) ^ 0x04c11db7) : (r << 1);\n    }\n    this.checksumTable[i] = (r & 0xffffffff);\n  }\n};\n\nOggOpusEncoder.prototype.setOpusControl = function( control, value ){\n  var location = this._malloc( 4 );\n  this.HEAP32[ location >> 2 ] = value;\n  this._opus_encoder_ctl( this.encoder, control, location );\n  this._free( location );\n};\n\nOggOpusEncoder.prototype.initCodec = function() {\n  var errLocation = this._malloc( 4 );\n  this.encoder = this._opus_encoder_create( this.config.encoderSampleRate, this.config.numberOfChannels, this.config.encoderApplication, errLocation );\n  this._free( errLocation );\n\n  if ( this.config.encoderBitRate ) {\n    this.setOpusControl( 4002, this.config.encoderBitRate );\n  }\n\n  if ( this.config.encoderComplexity ) {\n    this.setOpusControl( 4010, this.config.encoderComplexity );\n  }\n\n  this.encoderSamplesPerChannel = this.config.encoderSampleRate * this.config.encoderFrameSize / 1000;\n  this.encoderSamplesPerChannelPointer = this._malloc( 4 );\n  this.HEAP32[ this.encoderSamplesPerChannelPointer >> 2 ] = this.encoderSamplesPerChannel;\n\n  this.encoderBufferLength = this.encoderSamplesPerChannel * this.config.numberOfChannels;\n  this.encoderBufferPointer = this._malloc( this.encoderBufferLength * 4 ); // 4 bytes per sample\n  this.encoderBuffer = this.HEAPF32.subarray( this.encoderBufferPointer >> 2, (this.encoderBufferPointer >> 2) + this.encoderBufferLength );\n\n  this.encoderOutputMaxLength = 4000;\n  this.encoderOutputPointer = this._malloc( this.encoderOutputMaxLength );\n  this.encoderOutputBuffer = this.HEAPU8.subarray( this.encoderOutputPointer, this.encoderOutputPointer + this.encoderOutputMaxLength );\n};\n\nOggOpusEncoder.prototype.initResampler = function() {\n  var errLocation = this._malloc( 4 );\n  this.resampler = this._speex_resampler_init( this.config.numberOfChannels, this.config.originalSampleRate, this.config.encoderSampleRate, this.config.resampleQuality, errLocation );\n  this._free( errLocation );\n\n  this.resampleBufferIndex = 0;\n  this.resampleSamplesPerChannel = this.config.originalSampleRate * this.config.encoderFrameSize / 1000;\n  this.resampleSamplesPerChannelPointer = this._malloc( 4 );\n  this.HEAP32[ this.resampleSamplesPerChannelPointer >> 2 ] = this.resampleSamplesPerChannel;\n\n  this.resampleBufferLength = this.resampleSamplesPerChannel * this.config.numberOfChannels;\n  this.resampleBufferPointer = this._malloc( this.resampleBufferLength * 4 ); // 4 bytes per sample\n  this.resampleBuffer = this.HEAPF32.subarray( this.resampleBufferPointer >> 2, (this.resampleBufferPointer >> 2) + this.resampleBufferLength );\n};\n\nOggOpusEncoder.prototype.interleave = function( buffers ) {\n  for ( var i = 0; i < this.config.bufferLength; i++ ) {\n    for ( var channel = 0; channel < this.config.numberOfChannels; channel++ ) {\n      this.interleavedBuffers[ i * this.config.numberOfChannels + channel ] = buffers[ channel ][ i ];\n    }\n  }\n\n  return this.interleavedBuffers;\n};\n\nOggOpusEncoder.prototype.segmentPacket = function( packetLength ) {\n  var packetIndex = 0;\n  var exportPages = [];\n\n  while ( packetLength >= 0 ) {\n\n    if ( this.segmentTableIndex === 255 ) {\n      exportPages.push( this.generatePage() );\n      this.headerType = 1;\n    }\n\n    var segmentLength = Math.min( packetLength, 255 );\n    this.segmentTable[ this.segmentTableIndex++ ] = segmentLength;\n    this.segmentData.set( this.encoderOutputBuffer.subarray( packetIndex, packetIndex + segmentLength ), this.segmentDataIndex );\n    this.segmentDataIndex += segmentLength;\n    packetIndex += segmentLength;\n    packetLength -= 255;\n  }\n\n  this.granulePosition += ( 48 * this.config.encoderFrameSize );\n  if ( this.segmentTableIndex === 255 ) {\n    exportPages.push( this.generatePage() );\n    this.headerType = 0;\n  }\n\n  return exportPages;\n};\n\n\n// Run in AudioWorkletGlobal scope\nif (global['registerProcessor'] && global['AudioWorkletProcessor']) {\n\n  class EncoderWorklet extends global['AudioWorkletProcessor'] {\n\n    constructor(){\n      super();\n      this.continueProcess = true;\n      this.port.onmessage = ({ data }) => {\n        if (this.encoder) {\n          switch( data['command'] ){\n\n            case 'getHeaderPages':\n              this.postPage(this.encoder.generateIdPage());\n              this.postPage(this.encoder.generateCommentPage());\n              break;\n\n            case 'done':\n              this.postPage(this.encoder.encodeFinalFrame());\n              this.port.postMessage( {message: 'done'} );\n              break;\n\n            case 'flush':\n              this.postPage(this.encoder.flush());\n              this.port.postMessage( {message: 'flushed'} );\n              break;\n\n            default:\n              // Ignore any unknown commands and continue recieving commands\n          }\n        }\n\n        switch( data['command'] ){\n\n          case 'close':\n            this.continueProcess = false;\n            break;\n\n          case 'init':\n            if ( this.encoder ) {\n              this.encoder.destroy();\n            }\n            this.encoder = new OggOpusEncoder( data, Module );\n            this.port.postMessage( {message: 'ready'} );\n            break;\n\n          default:\n            // Ignore any unknown commands and continue recieving commands\n        }\n      }\n    }\n\n    process(inputs) {\n      if (this.encoder && inputs[0]){\n        this.encoder.encode( inputs[0] ).forEach(pageData => this.postPage(pageData));\n      }\n      return this.continueProcess;\n    }\n\n    postPage(pageData) {\n      if (pageData) {\n        this.port.postMessage( pageData, [pageData.page.buffer] );\n      }\n    }\n  }\n\n  global['registerProcessor']('encoder-worklet', EncoderWorklet);\n}\n\n// run in scriptProcessor worker scope\nelse {\n  var encoder;\n  var postPageGlobal = (pageData) => {\n    if (pageData) {\n      global['postMessage']( pageData, [pageData.page.buffer] );\n    }\n  }\n\n  global['onmessage'] = ({ data }) => {\n    if (encoder) {\n      switch( data['command'] ){\n\n        case 'encode':\n          encoder.encode( data['buffers'] ).forEach(pageData => postPageGlobal(pageData));\n          break;\n\n        case 'getHeaderPages':\n          postPageGlobal(encoder.generateIdPage());\n          postPageGlobal(encoder.generateCommentPage());\n          break;\n\n        case 'done':\n          postPageGlobal(encoder.encodeFinalFrame());\n          global['postMessage']( {message: 'done'} );\n          break;\n\n        case 'flush':\n          postPageGlobal(encoder.flush());\n          global['postMessage']( {message: 'flushed'} );\n          break;\n\n        default:\n          // Ignore any unknown commands and continue recieving commands\n      }\n    }\n\n    switch( data['command'] ){\n\n      case 'close':\n        global['close']();\n        break;\n\n      case 'init':\n        if ( encoder ) {\n          encoder.destroy();\n        }\n        encoder = new OggOpusEncoder( data, Module, global['postMessage'] );\n        global['postMessage']( {message: 'ready'} );\n        break;\n\n      default:\n        // Ignore any unknown commands and continue recieving commands\n    }\n  };\n\n  // Exports for unit testing\n  module.exports = {\n    Module: Module,\n    OggOpusEncoder: OggOpusEncoder\n  };\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZW5jb2Rlcldvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9lbmNvZGVyV29ya2VyLmpzPzhiM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmNvbnN0IE9nZ09wdXNFbmNvZGVyID0gZnVuY3Rpb24oIGNvbmZpZywgTW9kdWxlICl7XG5cbiAgaWYgKCAhTW9kdWxlICkge1xuICAgIHRocm93IG5ldyBFcnJvcignTW9kdWxlIHdpdGggZXhwb3J0cyByZXF1aXJlZCB0byBpbml0aWFsaXplIGFuIGVuY29kZXIgaW5zdGFuY2UnKTtcbiAgfVxuXG4gIHRoaXMuY29uZmlnID0gT2JqZWN0LmFzc2lnbih7IFxuICAgIGJ1ZmZlckxlbmd0aDogNDA5NiwgLy8gRGVmaW5lIHNpemUgb2YgaW5jb21pbmcgYnVmZmVyXG4gICAgZW5jb2RlckFwcGxpY2F0aW9uOiAyMDQ5LCAvLyAyMDQ4ID0gVm9pY2UgKExvd2VyIGZpZGVsaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjA0OSA9IEZ1bGwgQmFuZCBBdWRpbyAoSGlnaGVzdCBmaWRlbGl0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDIwNTEgPSBSZXN0cmljdGVkIExvdyBEZWxheSAoTG93ZXN0IGxhdGVuY3kpXG4gICAgZW5jb2RlckZyYW1lU2l6ZTogMjAsIC8vIFNwZWNpZmllZCBpbiBtcy5cbiAgICBlbmNvZGVyU2FtcGxlUmF0ZTogNDgwMDAsIC8vIERlc2lyZWQgZW5jb2Rpbmcgc2FtcGxlIHJhdGUuIEF1ZGlvIHdpbGwgYmUgcmVzYW1wbGVkXG4gICAgbWF4RnJhbWVzUGVyUGFnZTogNDAsIC8vIFRyYWRlb2ZmIGxhdGVuY3kgd2l0aCBvdmVyaGVhZFxuICAgIG51bWJlck9mQ2hhbm5lbHM6IDEsXG4gICAgb3JpZ2luYWxTYW1wbGVSYXRlOiA0NDEwMCxcbiAgICByZXNhbXBsZVF1YWxpdHk6IDMsIC8vIFZhbHVlIGJldHdlZW4gMCBhbmQgMTAgaW5jbHVzaXZlLiAxMCBiZWluZyBoaWdoZXN0IHF1YWxpdHkuXG4gICAgc2VyaWFsOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk2KVxuICB9LCBjb25maWcgKTtcblxuICB0aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlID0gTW9kdWxlLl9vcHVzX2VuY29kZXJfY3JlYXRlO1xuICB0aGlzLl9vcHVzX2VuY29kZXJfZGVzdHJveSA9IE1vZHVsZS5fb3B1c19lbmNvZGVyX2Rlc3Ryb3k7XG4gIHRoaXMuX29wdXNfZW5jb2Rlcl9jdGwgPSBNb2R1bGUuX29wdXNfZW5jb2Rlcl9jdGw7XG4gIHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0ID0gTW9kdWxlLl9zcGVleF9yZXNhbXBsZXJfcHJvY2Vzc19pbnRlcmxlYXZlZF9mbG9hdDtcbiAgdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2luaXQgPSBNb2R1bGUuX3NwZWV4X3Jlc2FtcGxlcl9pbml0O1xuICB0aGlzLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveSA9IE1vZHVsZS5fc3BlZXhfcmVzYW1wbGVyX2Rlc3Ryb3k7XG4gIHRoaXMuX29wdXNfZW5jb2RlX2Zsb2F0ID0gTW9kdWxlLl9vcHVzX2VuY29kZV9mbG9hdDtcbiAgdGhpcy5fZnJlZSA9IE1vZHVsZS5fZnJlZTtcbiAgdGhpcy5fbWFsbG9jID0gTW9kdWxlLl9tYWxsb2M7XG4gIHRoaXMuSEVBUFU4ID0gTW9kdWxlLkhFQVBVODtcbiAgdGhpcy5IRUFQMzIgPSBNb2R1bGUuSEVBUDMyO1xuICB0aGlzLkhFQVBGMzIgPSBNb2R1bGUuSEVBUEYzMjtcblxuICB0aGlzLnBhZ2VJbmRleCA9IDA7XG4gIHRoaXMuZ3JhbnVsZVBvc2l0aW9uID0gMDtcbiAgdGhpcy5zZWdtZW50RGF0YSA9IG5ldyBVaW50OEFycmF5KCA2NTAyNSApOyAvLyBNYXhpbXVtIGxlbmd0aCBvZiBvZ2dPcHVzIGRhdGFcbiAgdGhpcy5zZWdtZW50RGF0YUluZGV4ID0gMDtcbiAgdGhpcy5zZWdtZW50VGFibGUgPSBuZXcgVWludDhBcnJheSggMjU1ICk7IC8vIE1heGltdW0gZGF0YSBzZWdtZW50c1xuICB0aGlzLnNlZ21lbnRUYWJsZUluZGV4ID0gMDtcbiAgdGhpcy5mcmFtZXNJblBhZ2UgPSAwO1xuXG4gIHRoaXMuaW5pdENoZWNrc3VtVGFibGUoKTtcbiAgdGhpcy5pbml0Q29kZWMoKTtcbiAgdGhpcy5pbml0UmVzYW1wbGVyKCk7XG5cbiAgaWYgKCB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzID09PSAxICkge1xuICAgIHRoaXMuaW50ZXJsZWF2ZSA9IGZ1bmN0aW9uKCBidWZmZXJzICkgeyByZXR1cm4gYnVmZmVyc1swXTsgfTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aGlzLmludGVybGVhdmVkQnVmZmVycyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuY29uZmlnLmJ1ZmZlckxlbmd0aCAqIHRoaXMuY29uZmlnLm51bWJlck9mQ2hhbm5lbHMgKTtcbiAgfVxuXG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oIGJ1ZmZlcnMgKSB7XG4gIHZhciBzYW1wbGVzID0gdGhpcy5pbnRlcmxlYXZlKCBidWZmZXJzICk7XG4gIHZhciBzYW1wbGVJbmRleCA9IDA7XG4gIHZhciBleHBvcnRQYWdlcyA9IFtdO1xuXG4gIHdoaWxlICggc2FtcGxlSW5kZXggPCBzYW1wbGVzLmxlbmd0aCApIHtcblxuICAgIHZhciBsZW5ndGhUb0NvcHkgPSBNYXRoLm1pbiggdGhpcy5yZXNhbXBsZUJ1ZmZlckxlbmd0aCAtIHRoaXMucmVzYW1wbGVCdWZmZXJJbmRleCwgc2FtcGxlcy5sZW5ndGggLSBzYW1wbGVJbmRleCApO1xuICAgIHRoaXMucmVzYW1wbGVCdWZmZXIuc2V0KCBzYW1wbGVzLnN1YmFycmF5KCBzYW1wbGVJbmRleCwgc2FtcGxlSW5kZXgrbGVuZ3RoVG9Db3B5ICksIHRoaXMucmVzYW1wbGVCdWZmZXJJbmRleCApO1xuICAgIHNhbXBsZUluZGV4ICs9IGxlbmd0aFRvQ29weTtcbiAgICB0aGlzLnJlc2FtcGxlQnVmZmVySW5kZXggKz0gbGVuZ3RoVG9Db3B5O1xuXG4gICAgaWYgKCB0aGlzLnJlc2FtcGxlQnVmZmVySW5kZXggPT09IHRoaXMucmVzYW1wbGVCdWZmZXJMZW5ndGggKSB7XG4gICAgICB0aGlzLl9zcGVleF9yZXNhbXBsZXJfcHJvY2Vzc19pbnRlcmxlYXZlZF9mbG9hdCggdGhpcy5yZXNhbXBsZXIsIHRoaXMucmVzYW1wbGVCdWZmZXJQb2ludGVyLCB0aGlzLnJlc2FtcGxlU2FtcGxlc1BlckNoYW5uZWxQb2ludGVyLCB0aGlzLmVuY29kZXJCdWZmZXJQb2ludGVyLCB0aGlzLmVuY29kZXJTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXIgKTtcbiAgICAgIHZhciBwYWNrZXRMZW5ndGggPSB0aGlzLl9vcHVzX2VuY29kZV9mbG9hdCggdGhpcy5lbmNvZGVyLCB0aGlzLmVuY29kZXJCdWZmZXJQb2ludGVyLCB0aGlzLmVuY29kZXJTYW1wbGVzUGVyQ2hhbm5lbCwgdGhpcy5lbmNvZGVyT3V0cHV0UG9pbnRlciwgdGhpcy5lbmNvZGVyT3V0cHV0TWF4TGVuZ3RoICk7XG4gICAgICBleHBvcnRQYWdlcy5jb25jYXQodGhpcy5zZWdtZW50UGFja2V0KCBwYWNrZXRMZW5ndGggKSk7XG4gICAgICB0aGlzLnJlc2FtcGxlQnVmZmVySW5kZXggPSAwO1xuXG4gICAgICB0aGlzLmZyYW1lc0luUGFnZSsrO1xuICAgICAgaWYgKCB0aGlzLmZyYW1lc0luUGFnZSA+PSB0aGlzLmNvbmZpZy5tYXhGcmFtZXNQZXJQYWdlICkge1xuICAgICAgICBleHBvcnRQYWdlcy5wdXNoKCB0aGlzLmdlbmVyYXRlUGFnZSgpICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydFBhZ2VzO1xufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCB0aGlzLmVuY29kZXIgKSB7XG4gICAgdGhpcy5fZnJlZSh0aGlzLmVuY29kZXJTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXIpO1xuICAgIGRlbGV0ZSB0aGlzLmVuY29kZXJTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXI7XG4gICAgdGhpcy5fZnJlZSh0aGlzLmVuY29kZXJCdWZmZXJQb2ludGVyKTtcbiAgICBkZWxldGUgdGhpcy5lbmNvZGVyQnVmZmVyUG9pbnRlcjtcbiAgICB0aGlzLl9mcmVlKHRoaXMuZW5jb2Rlck91dHB1dFBvaW50ZXIpO1xuICAgIGRlbGV0ZSB0aGlzLmVuY29kZXJPdXRwdXRQb2ludGVyO1xuICAgIHRoaXMuX2ZyZWUodGhpcy5yZXNhbXBsZVNhbXBsZXNQZXJDaGFubmVsUG9pbnRlcik7XG4gICAgZGVsZXRlIHRoaXMucmVzYW1wbGVTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXI7XG4gICAgdGhpcy5fZnJlZSh0aGlzLnJlc2FtcGxlQnVmZmVyUG9pbnRlcik7XG4gICAgZGVsZXRlIHRoaXMucmVzYW1wbGVCdWZmZXJQb2ludGVyO1xuICAgIHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95KHRoaXMucmVzYW1wbGVyKTtcbiAgICBkZWxldGUgdGhpcy5yZXNhbXBsZXI7XG4gICAgdGhpcy5fb3B1c19lbmNvZGVyX2Rlc3Ryb3kodGhpcy5lbmNvZGVyKTtcbiAgICBkZWxldGUgdGhpcy5lbmNvZGVyO1xuICB9XG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV4cG9ydFBhZ2U7XG4gIGlmICggdGhpcy5mcmFtZXNJblBhZ2UgKSB7XG4gICAgZXhwb3J0UGFnZSA9IHRoaXMuZ2VuZXJhdGVQYWdlKCk7XG4gIH1cbiAgLy8gZGlzY2FyZCBhbnkgcGVuZGluZyBkYXRhIGluIHJlc2FtcGxlIGJ1ZmZlciAob25seSBhIGZldyBtcyB3b3J0aClcbiAgdGhpcy5yZXNhbXBsZUJ1ZmZlckluZGV4ID0gMDtcbiAgcmV0dXJuIGV4cG9ydFBhZ2U7XG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlRmluYWxGcmFtZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIHRoaXMucmVzYW1wbGVCdWZmZXJJbmRleCA+IDAgKSB7XG4gICAgdmFyIGZpbmFsRnJhbWVCdWZmZXJzID0gW107XG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jb25maWcubnVtYmVyT2ZDaGFubmVsczsgKytpICkge1xuICAgICAgZmluYWxGcmFtZUJ1ZmZlcnMucHVzaCggbmV3IEZsb2F0MzJBcnJheSggdGhpcy5jb25maWcuYnVmZmVyTGVuZ3RoIC0gKHRoaXMucmVzYW1wbGVCdWZmZXJJbmRleCAvIHRoaXMuY29uZmlnLm51bWJlck9mQ2hhbm5lbHMpICkpO1xuICAgIH1cbiAgICB0aGlzLmVuY29kZSggZmluYWxGcmFtZUJ1ZmZlcnMgKTtcbiAgfVxuICB0aGlzLmhlYWRlclR5cGUgKz0gNDtcbiAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVQYWdlKCk7XG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuZ2V0Q2hlY2tzdW0gPSBmdW5jdGlvbiggZGF0YSApe1xuICB2YXIgY2hlY2tzdW0gPSAwO1xuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrICkge1xuICAgIGNoZWNrc3VtID0gKGNoZWNrc3VtIDw8IDgpIF4gdGhpcy5jaGVja3N1bVRhYmxlWyAoKGNoZWNrc3VtPj4+MjQpICYgMHhmZikgXiBkYXRhW2ldIF07XG4gIH1cbiAgcmV0dXJuIGNoZWNrc3VtID4+PiAwO1xufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLmdlbmVyYXRlQ29tbWVudFBhZ2UgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VnbWVudERhdGFWaWV3ID0gbmV3IERhdGFWaWV3KCB0aGlzLnNlZ21lbnREYXRhLmJ1ZmZlciApO1xuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDMyKCAwLCAxOTM3MDc2MzAzLCB0cnVlICkgLy8gTWFnaWMgU2lnbmF0dXJlICdPcHVzJ1xuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDMyKCA0LCAxOTM2MTU0OTY0LCB0cnVlICkgLy8gTWFnaWMgU2lnbmF0dXJlICdUYWdzJ1xuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDMyKCA4LCAxMCwgdHJ1ZSApOyAvLyBWZW5kb3IgTGVuZ3RoXG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50MzIoIDEyLCAxODY4Nzg0OTc4LCB0cnVlICk7IC8vIFZlbmRvciBuYW1lICdSZWNvJ1xuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDMyKCAxNiwgMTkxOTI0NzQ3NCwgdHJ1ZSApOyAvLyBWZW5kb3IgbmFtZSAncmRlcidcbiAgc2VnbWVudERhdGFWaWV3LnNldFVpbnQxNiggMjAsIDIxMzIyLCB0cnVlICk7IC8vIFZlbmRvciBuYW1lICdKUydcbiAgc2VnbWVudERhdGFWaWV3LnNldFVpbnQzMiggMjIsIDAsIHRydWUgKTsgLy8gVXNlciBDb21tZW50IExpc3QgTGVuZ3RoXG4gIHRoaXMuc2VnbWVudFRhYmxlSW5kZXggPSAxO1xuICB0aGlzLnNlZ21lbnREYXRhSW5kZXggPSB0aGlzLnNlZ21lbnRUYWJsZVswXSA9IDI2O1xuICB0aGlzLmhlYWRlclR5cGUgPSAwO1xuICByZXR1cm4gdGhpcy5nZW5lcmF0ZVBhZ2UoKTtcbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5nZW5lcmF0ZUlkUGFnZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWdtZW50RGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoIHRoaXMuc2VnbWVudERhdGEuYnVmZmVyICk7XG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50MzIoIDAsIDE5MzcwNzYzMDMsIHRydWUgKSAvLyBNYWdpYyBTaWduYXR1cmUgJ09wdXMnXG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50MzIoIDQsIDE2ODQxMDQ1MjAsIHRydWUgKSAvLyBNYWdpYyBTaWduYXR1cmUgJ0hlYWQnXG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50OCggOCwgMSwgdHJ1ZSApOyAvLyBWZXJzaW9uXG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50OCggOSwgdGhpcy5jb25maWcubnVtYmVyT2ZDaGFubmVscywgdHJ1ZSApOyAvLyBDaGFubmVsIGNvdW50XG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50MTYoIDEwLCAzODQwLCB0cnVlICk7IC8vIHByZS1za2lwICg4MG1zKVxuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDMyKCAxMiwgdGhpcy5jb25maWcub3JpZ2luYWxTYW1wbGVSYXRlT3ZlcnJpZGUgfHwgdGhpcy5jb25maWcub3JpZ2luYWxTYW1wbGVSYXRlLCB0cnVlICk7IC8vIG9yaWdpbmFsIHNhbXBsZSByYXRlXG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50MTYoIDE2LCAwLCB0cnVlICk7IC8vIG91dHB1dCBnYWluXG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50OCggMTgsIDAsIHRydWUgKTsgLy8gY2hhbm5lbCBtYXAgMCA9IG1vbm8gb3Igc3RlcmVvXG4gIHRoaXMuc2VnbWVudFRhYmxlSW5kZXggPSAxO1xuICB0aGlzLnNlZ21lbnREYXRhSW5kZXggPSB0aGlzLnNlZ21lbnRUYWJsZVswXSA9IDE5O1xuICB0aGlzLmhlYWRlclR5cGUgPSAyO1xuICByZXR1cm4gdGhpcy5nZW5lcmF0ZVBhZ2UoKTtcbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5nZW5lcmF0ZVBhZ2UgPSBmdW5jdGlvbigpe1xuICB2YXIgZ3JhbnVsZVBvc2l0aW9uID0gKCB0aGlzLmxhc3RQb3NpdGl2ZUdyYW51bGVQb3NpdGlvbiA9PT0gdGhpcy5ncmFudWxlUG9zaXRpb24pID8gLTEgOiB0aGlzLmdyYW51bGVQb3NpdGlvbjtcbiAgdmFyIHBhZ2VCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoICAyNyArIHRoaXMuc2VnbWVudFRhYmxlSW5kZXggKyB0aGlzLnNlZ21lbnREYXRhSW5kZXggKTtcbiAgdmFyIHBhZ2VCdWZmZXJWaWV3ID0gbmV3IERhdGFWaWV3KCBwYWdlQnVmZmVyICk7XG4gIHZhciBwYWdlID0gbmV3IFVpbnQ4QXJyYXkoIHBhZ2VCdWZmZXIgKTtcblxuICBwYWdlQnVmZmVyVmlldy5zZXRVaW50MzIoIDAsIDEzOTkyODU1ODMsIHRydWUpOyAvLyBDYXB0dXJlIFBhdHRlcm4gc3RhcnRzIGFsbCBwYWdlIGhlYWRlcnMgJ09nZ1MnXG4gIHBhZ2VCdWZmZXJWaWV3LnNldFVpbnQ4KCA0LCAwLCB0cnVlICk7IC8vIFZlcnNpb25cbiAgcGFnZUJ1ZmZlclZpZXcuc2V0VWludDgoIDUsIHRoaXMuaGVhZGVyVHlwZSwgdHJ1ZSApOyAvLyAxID0gY29udGludWF0aW9uLCAyID0gYmVnaW5uaW5nIG9mIHN0cmVhbSwgNCA9IGVuZCBvZiBzdHJlYW1cblxuICAvLyBOdW1iZXIgb2Ygc2FtcGxlcyB1cHRvIGFuZCBpbmNsdWRpbmcgdGhpcyBwYWdlIGF0IDQ4MDAwSHosIGludG8gc2lnbmVkIDY0IGJpdCBMaXR0bGUgRW5kaWFuIGludGVnZXJcbiAgLy8gSmF2YXNjcmlwdCBOdW1iZXIgbWF4aW11bSB2YWx1ZSBpcyA1MyBiaXRzIG9yIDJeNTMgLSAxIFxuICBwYWdlQnVmZmVyVmlldy5zZXRVaW50MzIoIDYsIGdyYW51bGVQb3NpdGlvbiwgdHJ1ZSApO1xuICBpZiAoZ3JhbnVsZVBvc2l0aW9uIDwgMCkge1xuICAgIHBhZ2VCdWZmZXJWaWV3LnNldEludDMyKCAxMCwgTWF0aC5jZWlsKGdyYW51bGVQb3NpdGlvbi80Mjk0OTY3Mjk3KSAtIDEsIHRydWUgKTtcbiAgfVxuICBlbHNlIHtcbiAgICBwYWdlQnVmZmVyVmlldy5zZXRJbnQzMiggMTAsIE1hdGguZmxvb3IoZ3JhbnVsZVBvc2l0aW9uLzQyOTQ5NjcyOTYpLCB0cnVlICk7XG4gIH1cblxuICBwYWdlQnVmZmVyVmlldy5zZXRVaW50MzIoIDE0LCB0aGlzLmNvbmZpZy5zZXJpYWwsIHRydWUgKTsgLy8gQml0c3RyZWFtIHNlcmlhbCBudW1iZXJcbiAgcGFnZUJ1ZmZlclZpZXcuc2V0VWludDMyKCAxOCwgdGhpcy5wYWdlSW5kZXgrKywgdHJ1ZSApOyAvLyBQYWdlIHNlcXVlbmNlIG51bWJlclxuICBwYWdlQnVmZmVyVmlldy5zZXRVaW50OCggMjYsIHRoaXMuc2VnbWVudFRhYmxlSW5kZXgsIHRydWUgKTsgLy8gTnVtYmVyIG9mIHNlZ21lbnRzIGluIHBhZ2UuXG4gIHBhZ2Uuc2V0KCB0aGlzLnNlZ21lbnRUYWJsZS5zdWJhcnJheSgwLCB0aGlzLnNlZ21lbnRUYWJsZUluZGV4KSwgMjcgKTsgLy8gU2VnbWVudCBUYWJsZVxuICBwYWdlLnNldCggdGhpcy5zZWdtZW50RGF0YS5zdWJhcnJheSgwLCB0aGlzLnNlZ21lbnREYXRhSW5kZXgpLCAyNyArIHRoaXMuc2VnbWVudFRhYmxlSW5kZXggKTsgLy8gU2VnbWVudCBEYXRhXG4gIHBhZ2VCdWZmZXJWaWV3LnNldFVpbnQzMiggMjIsIHRoaXMuZ2V0Q2hlY2tzdW0oIHBhZ2UgKSwgdHJ1ZSApOyAvLyBDaGVja3N1bVxuXG4gIHZhciBleHBvcnRQYWdlID0geyBtZXNzYWdlOiAncGFnZScsIHBhZ2U6IHBhZ2UsIHNhbXBsZVBvc2l0aW9uOiB0aGlzLmdyYW51bGVQb3NpdGlvbiB9O1xuICB0aGlzLnNlZ21lbnRUYWJsZUluZGV4ID0gMDtcbiAgdGhpcy5zZWdtZW50RGF0YUluZGV4ID0gMDtcbiAgdGhpcy5mcmFtZXNJblBhZ2UgPSAwO1xuICBpZiAoIGdyYW51bGVQb3NpdGlvbiA+IDAgKSB7XG4gICAgdGhpcy5sYXN0UG9zaXRpdmVHcmFudWxlUG9zaXRpb24gPSBncmFudWxlUG9zaXRpb247XG4gIH1cblxuICByZXR1cm4gZXhwb3J0UGFnZTtcbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5pbml0Q2hlY2tzdW1UYWJsZSA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2hlY2tzdW1UYWJsZSA9IFtdO1xuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKyApIHtcbiAgICB2YXIgciA9IGkgPDwgMjQ7XG4gICAgZm9yICggdmFyIGogPSAwOyBqIDwgODsgaisrICkge1xuICAgICAgciA9ICgociAmIDB4ODAwMDAwMDApICE9IDApID8gKChyIDw8IDEpIF4gMHgwNGMxMWRiNykgOiAociA8PCAxKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja3N1bVRhYmxlW2ldID0gKHIgJiAweGZmZmZmZmZmKTtcbiAgfVxufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLnNldE9wdXNDb250cm9sID0gZnVuY3Rpb24oIGNvbnRyb2wsIHZhbHVlICl7XG4gIHZhciBsb2NhdGlvbiA9IHRoaXMuX21hbGxvYyggNCApO1xuICB0aGlzLkhFQVAzMlsgbG9jYXRpb24gPj4gMiBdID0gdmFsdWU7XG4gIHRoaXMuX29wdXNfZW5jb2Rlcl9jdGwoIHRoaXMuZW5jb2RlciwgY29udHJvbCwgbG9jYXRpb24gKTtcbiAgdGhpcy5fZnJlZSggbG9jYXRpb24gKTtcbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5pbml0Q29kZWMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVyckxvY2F0aW9uID0gdGhpcy5fbWFsbG9jKCA0ICk7XG4gIHRoaXMuZW5jb2RlciA9IHRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGUoIHRoaXMuY29uZmlnLmVuY29kZXJTYW1wbGVSYXRlLCB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzLCB0aGlzLmNvbmZpZy5lbmNvZGVyQXBwbGljYXRpb24sIGVyckxvY2F0aW9uICk7XG4gIHRoaXMuX2ZyZWUoIGVyckxvY2F0aW9uICk7XG5cbiAgaWYgKCB0aGlzLmNvbmZpZy5lbmNvZGVyQml0UmF0ZSApIHtcbiAgICB0aGlzLnNldE9wdXNDb250cm9sKCA0MDAyLCB0aGlzLmNvbmZpZy5lbmNvZGVyQml0UmF0ZSApO1xuICB9XG5cbiAgaWYgKCB0aGlzLmNvbmZpZy5lbmNvZGVyQ29tcGxleGl0eSApIHtcbiAgICB0aGlzLnNldE9wdXNDb250cm9sKCA0MDEwLCB0aGlzLmNvbmZpZy5lbmNvZGVyQ29tcGxleGl0eSApO1xuICB9XG5cbiAgdGhpcy5lbmNvZGVyU2FtcGxlc1BlckNoYW5uZWwgPSB0aGlzLmNvbmZpZy5lbmNvZGVyU2FtcGxlUmF0ZSAqIHRoaXMuY29uZmlnLmVuY29kZXJGcmFtZVNpemUgLyAxMDAwO1xuICB0aGlzLmVuY29kZXJTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXIgPSB0aGlzLl9tYWxsb2MoIDQgKTtcbiAgdGhpcy5IRUFQMzJbIHRoaXMuZW5jb2RlclNhbXBsZXNQZXJDaGFubmVsUG9pbnRlciA+PiAyIF0gPSB0aGlzLmVuY29kZXJTYW1wbGVzUGVyQ2hhbm5lbDtcblxuICB0aGlzLmVuY29kZXJCdWZmZXJMZW5ndGggPSB0aGlzLmVuY29kZXJTYW1wbGVzUGVyQ2hhbm5lbCAqIHRoaXMuY29uZmlnLm51bWJlck9mQ2hhbm5lbHM7XG4gIHRoaXMuZW5jb2RlckJ1ZmZlclBvaW50ZXIgPSB0aGlzLl9tYWxsb2MoIHRoaXMuZW5jb2RlckJ1ZmZlckxlbmd0aCAqIDQgKTsgLy8gNCBieXRlcyBwZXIgc2FtcGxlXG4gIHRoaXMuZW5jb2RlckJ1ZmZlciA9IHRoaXMuSEVBUEYzMi5zdWJhcnJheSggdGhpcy5lbmNvZGVyQnVmZmVyUG9pbnRlciA+PiAyLCAodGhpcy5lbmNvZGVyQnVmZmVyUG9pbnRlciA+PiAyKSArIHRoaXMuZW5jb2RlckJ1ZmZlckxlbmd0aCApO1xuXG4gIHRoaXMuZW5jb2Rlck91dHB1dE1heExlbmd0aCA9IDQwMDA7XG4gIHRoaXMuZW5jb2Rlck91dHB1dFBvaW50ZXIgPSB0aGlzLl9tYWxsb2MoIHRoaXMuZW5jb2Rlck91dHB1dE1heExlbmd0aCApO1xuICB0aGlzLmVuY29kZXJPdXRwdXRCdWZmZXIgPSB0aGlzLkhFQVBVOC5zdWJhcnJheSggdGhpcy5lbmNvZGVyT3V0cHV0UG9pbnRlciwgdGhpcy5lbmNvZGVyT3V0cHV0UG9pbnRlciArIHRoaXMuZW5jb2Rlck91dHB1dE1heExlbmd0aCApO1xufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLmluaXRSZXNhbXBsZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVyckxvY2F0aW9uID0gdGhpcy5fbWFsbG9jKCA0ICk7XG4gIHRoaXMucmVzYW1wbGVyID0gdGhpcy5fc3BlZXhfcmVzYW1wbGVyX2luaXQoIHRoaXMuY29uZmlnLm51bWJlck9mQ2hhbm5lbHMsIHRoaXMuY29uZmlnLm9yaWdpbmFsU2FtcGxlUmF0ZSwgdGhpcy5jb25maWcuZW5jb2RlclNhbXBsZVJhdGUsIHRoaXMuY29uZmlnLnJlc2FtcGxlUXVhbGl0eSwgZXJyTG9jYXRpb24gKTtcbiAgdGhpcy5fZnJlZSggZXJyTG9jYXRpb24gKTtcblxuICB0aGlzLnJlc2FtcGxlQnVmZmVySW5kZXggPSAwO1xuICB0aGlzLnJlc2FtcGxlU2FtcGxlc1BlckNoYW5uZWwgPSB0aGlzLmNvbmZpZy5vcmlnaW5hbFNhbXBsZVJhdGUgKiB0aGlzLmNvbmZpZy5lbmNvZGVyRnJhbWVTaXplIC8gMTAwMDtcbiAgdGhpcy5yZXNhbXBsZVNhbXBsZXNQZXJDaGFubmVsUG9pbnRlciA9IHRoaXMuX21hbGxvYyggNCApO1xuICB0aGlzLkhFQVAzMlsgdGhpcy5yZXNhbXBsZVNhbXBsZXNQZXJDaGFubmVsUG9pbnRlciA+PiAyIF0gPSB0aGlzLnJlc2FtcGxlU2FtcGxlc1BlckNoYW5uZWw7XG5cbiAgdGhpcy5yZXNhbXBsZUJ1ZmZlckxlbmd0aCA9IHRoaXMucmVzYW1wbGVTYW1wbGVzUGVyQ2hhbm5lbCAqIHRoaXMuY29uZmlnLm51bWJlck9mQ2hhbm5lbHM7XG4gIHRoaXMucmVzYW1wbGVCdWZmZXJQb2ludGVyID0gdGhpcy5fbWFsbG9jKCB0aGlzLnJlc2FtcGxlQnVmZmVyTGVuZ3RoICogNCApOyAvLyA0IGJ5dGVzIHBlciBzYW1wbGVcbiAgdGhpcy5yZXNhbXBsZUJ1ZmZlciA9IHRoaXMuSEVBUEYzMi5zdWJhcnJheSggdGhpcy5yZXNhbXBsZUJ1ZmZlclBvaW50ZXIgPj4gMiwgKHRoaXMucmVzYW1wbGVCdWZmZXJQb2ludGVyID4+IDIpICsgdGhpcy5yZXNhbXBsZUJ1ZmZlckxlbmd0aCApO1xufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLmludGVybGVhdmUgPSBmdW5jdGlvbiggYnVmZmVycyApIHtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jb25maWcuYnVmZmVyTGVuZ3RoOyBpKysgKSB7XG4gICAgZm9yICggdmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5jb25maWcubnVtYmVyT2ZDaGFubmVsczsgY2hhbm5lbCsrICkge1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZEJ1ZmZlcnNbIGkgKiB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzICsgY2hhbm5lbCBdID0gYnVmZmVyc1sgY2hhbm5lbCBdWyBpIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzO1xufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLnNlZ21lbnRQYWNrZXQgPSBmdW5jdGlvbiggcGFja2V0TGVuZ3RoICkge1xuICB2YXIgcGFja2V0SW5kZXggPSAwO1xuICB2YXIgZXhwb3J0UGFnZXMgPSBbXTtcblxuICB3aGlsZSAoIHBhY2tldExlbmd0aCA+PSAwICkge1xuXG4gICAgaWYgKCB0aGlzLnNlZ21lbnRUYWJsZUluZGV4ID09PSAyNTUgKSB7XG4gICAgICBleHBvcnRQYWdlcy5wdXNoKCB0aGlzLmdlbmVyYXRlUGFnZSgpICk7XG4gICAgICB0aGlzLmhlYWRlclR5cGUgPSAxO1xuICAgIH1cblxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gTWF0aC5taW4oIHBhY2tldExlbmd0aCwgMjU1ICk7XG4gICAgdGhpcy5zZWdtZW50VGFibGVbIHRoaXMuc2VnbWVudFRhYmxlSW5kZXgrKyBdID0gc2VnbWVudExlbmd0aDtcbiAgICB0aGlzLnNlZ21lbnREYXRhLnNldCggdGhpcy5lbmNvZGVyT3V0cHV0QnVmZmVyLnN1YmFycmF5KCBwYWNrZXRJbmRleCwgcGFja2V0SW5kZXggKyBzZWdtZW50TGVuZ3RoICksIHRoaXMuc2VnbWVudERhdGFJbmRleCApO1xuICAgIHRoaXMuc2VnbWVudERhdGFJbmRleCArPSBzZWdtZW50TGVuZ3RoO1xuICAgIHBhY2tldEluZGV4ICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgcGFja2V0TGVuZ3RoIC09IDI1NTtcbiAgfVxuXG4gIHRoaXMuZ3JhbnVsZVBvc2l0aW9uICs9ICggNDggKiB0aGlzLmNvbmZpZy5lbmNvZGVyRnJhbWVTaXplICk7XG4gIGlmICggdGhpcy5zZWdtZW50VGFibGVJbmRleCA9PT0gMjU1ICkge1xuICAgIGV4cG9ydFBhZ2VzLnB1c2goIHRoaXMuZ2VuZXJhdGVQYWdlKCkgKTtcbiAgICB0aGlzLmhlYWRlclR5cGUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydFBhZ2VzO1xufTtcblxuXG4vLyBSdW4gaW4gQXVkaW9Xb3JrbGV0R2xvYmFsIHNjb3BlXG5pZiAoZ2xvYmFsWydyZWdpc3RlclByb2Nlc3NvciddICYmIGdsb2JhbFsnQXVkaW9Xb3JrbGV0UHJvY2Vzc29yJ10pIHtcblxuICBjbGFzcyBFbmNvZGVyV29ya2xldCBleHRlbmRzIGdsb2JhbFsnQXVkaW9Xb3JrbGV0UHJvY2Vzc29yJ10ge1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLmNvbnRpbnVlUHJvY2VzcyA9IHRydWU7XG4gICAgICB0aGlzLnBvcnQub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmVuY29kZXIpIHtcbiAgICAgICAgICBzd2l0Y2goIGRhdGFbJ2NvbW1hbmQnXSApe1xuXG4gICAgICAgICAgICBjYXNlICdnZXRIZWFkZXJQYWdlcyc6XG4gICAgICAgICAgICAgIHRoaXMucG9zdFBhZ2UodGhpcy5lbmNvZGVyLmdlbmVyYXRlSWRQYWdlKCkpO1xuICAgICAgICAgICAgICB0aGlzLnBvc3RQYWdlKHRoaXMuZW5jb2Rlci5nZW5lcmF0ZUNvbW1lbnRQYWdlKCkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICAgIHRoaXMucG9zdFBhZ2UodGhpcy5lbmNvZGVyLmVuY29kZUZpbmFsRnJhbWUoKSk7XG4gICAgICAgICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSgge21lc3NhZ2U6ICdkb25lJ30gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2ZsdXNoJzpcbiAgICAgICAgICAgICAgdGhpcy5wb3N0UGFnZSh0aGlzLmVuY29kZXIuZmx1c2goKSk7XG4gICAgICAgICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSgge21lc3NhZ2U6ICdmbHVzaGVkJ30gKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgdW5rbm93biBjb21tYW5kcyBhbmQgY29udGludWUgcmVjaWV2aW5nIGNvbW1hbmRzXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoKCBkYXRhWydjb21tYW5kJ10gKXtcblxuICAgICAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgICAgIHRoaXMuY29udGludWVQcm9jZXNzID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2luaXQnOlxuICAgICAgICAgICAgaWYgKCB0aGlzLmVuY29kZXIgKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW5jb2Rlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVuY29kZXIgPSBuZXcgT2dnT3B1c0VuY29kZXIoIGRhdGEsIE1vZHVsZSApO1xuICAgICAgICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKCB7bWVzc2FnZTogJ3JlYWR5J30gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIElnbm9yZSBhbnkgdW5rbm93biBjb21tYW5kcyBhbmQgY29udGludWUgcmVjaWV2aW5nIGNvbW1hbmRzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9jZXNzKGlucHV0cykge1xuICAgICAgaWYgKHRoaXMuZW5jb2RlciAmJiBpbnB1dHNbMF0pe1xuICAgICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKCBpbnB1dHNbMF0gKS5mb3JFYWNoKHBhZ2VEYXRhID0+IHRoaXMucG9zdFBhZ2UocGFnZURhdGEpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbnRpbnVlUHJvY2VzcztcbiAgICB9XG5cbiAgICBwb3N0UGFnZShwYWdlRGF0YSkge1xuICAgICAgaWYgKHBhZ2VEYXRhKSB7XG4gICAgICAgIHRoaXMucG9ydC5wb3N0TWVzc2FnZSggcGFnZURhdGEsIFtwYWdlRGF0YS5wYWdlLmJ1ZmZlcl0gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnbG9iYWxbJ3JlZ2lzdGVyUHJvY2Vzc29yJ10oJ2VuY29kZXItd29ya2xldCcsIEVuY29kZXJXb3JrbGV0KTtcbn1cblxuLy8gcnVuIGluIHNjcmlwdFByb2Nlc3NvciB3b3JrZXIgc2NvcGVcbmVsc2Uge1xuICB2YXIgZW5jb2RlcjtcbiAgdmFyIHBvc3RQYWdlR2xvYmFsID0gKHBhZ2VEYXRhKSA9PiB7XG4gICAgaWYgKHBhZ2VEYXRhKSB7XG4gICAgICBnbG9iYWxbJ3Bvc3RNZXNzYWdlJ10oIHBhZ2VEYXRhLCBbcGFnZURhdGEucGFnZS5idWZmZXJdICk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsWydvbm1lc3NhZ2UnXSA9ICh7IGRhdGEgfSkgPT4ge1xuICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICBzd2l0Y2goIGRhdGFbJ2NvbW1hbmQnXSApe1xuXG4gICAgICAgIGNhc2UgJ2VuY29kZSc6XG4gICAgICAgICAgZW5jb2Rlci5lbmNvZGUoIGRhdGFbJ2J1ZmZlcnMnXSApLmZvckVhY2gocGFnZURhdGEgPT4gcG9zdFBhZ2VHbG9iYWwocGFnZURhdGEpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdnZXRIZWFkZXJQYWdlcyc6XG4gICAgICAgICAgcG9zdFBhZ2VHbG9iYWwoZW5jb2Rlci5nZW5lcmF0ZUlkUGFnZSgpKTtcbiAgICAgICAgICBwb3N0UGFnZUdsb2JhbChlbmNvZGVyLmdlbmVyYXRlQ29tbWVudFBhZ2UoKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgcG9zdFBhZ2VHbG9iYWwoZW5jb2Rlci5lbmNvZGVGaW5hbEZyYW1lKCkpO1xuICAgICAgICAgIGdsb2JhbFsncG9zdE1lc3NhZ2UnXSgge21lc3NhZ2U6ICdkb25lJ30gKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgICAgcG9zdFBhZ2VHbG9iYWwoZW5jb2Rlci5mbHVzaCgpKTtcbiAgICAgICAgICBnbG9iYWxbJ3Bvc3RNZXNzYWdlJ10oIHttZXNzYWdlOiAnZmx1c2hlZCd9ICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBJZ25vcmUgYW55IHVua25vd24gY29tbWFuZHMgYW5kIGNvbnRpbnVlIHJlY2lldmluZyBjb21tYW5kc1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCggZGF0YVsnY29tbWFuZCddICl7XG5cbiAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgZ2xvYmFsWydjbG9zZSddKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgaWYgKCBlbmNvZGVyICkge1xuICAgICAgICAgIGVuY29kZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZXIgPSBuZXcgT2dnT3B1c0VuY29kZXIoIGRhdGEsIE1vZHVsZSwgZ2xvYmFsWydwb3N0TWVzc2FnZSddICk7XG4gICAgICAgIGdsb2JhbFsncG9zdE1lc3NhZ2UnXSgge21lc3NhZ2U6ICdyZWFkeSd9ICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJZ25vcmUgYW55IHVua25vd24gY29tbWFuZHMgYW5kIGNvbnRpbnVlIHJlY2lldmluZyBjb21tYW5kc1xuICAgIH1cbiAgfTtcblxuICAvLyBFeHBvcnRzIGZvciB1bml0IHRlc3RpbmdcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgTW9kdWxlOiBNb2R1bGUsXG4gICAgT2dnT3B1c0VuY29kZXI6IE9nZ09wdXNFbmNvZGVyXG4gIH07XG59XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/encoderWorker.js\n");
=======
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EmsdkModule\", function() { return EmsdkModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OggOpusEncoder\", function() { return OggOpusEncoder; });\n\n\nvar encoder;\n\n\nconst EmsdkModule = Module;\nconst OggOpusEncoder = function( config, Module ){\n\n  if ( !Module ) {\n    throw new Error('Module with exports required to initialize an encoder instance');\n  }\n\n  this.config = Object.assign({ \n    encoderApplication: 2049, // 2048 = Voice (Lower fidelity)\n                              // 2049 = Full Band Audio (Highest fidelity)\n                              // 2051 = Restricted Low Delay (Lowest latency)\n    encoderFrameSize: 20, // Specified in ms.\n    encoderSampleRate: 48000, // Desired encoding sample rate. Audio will be resampled\n    maxFramesPerPage: 40, // Tradeoff latency with overhead\n    numberOfChannels: 1,\n    originalSampleRate: 44100,\n    resampleQuality: 3, // Value between 0 and 10 inclusive. 10 being highest quality.\n    serial: Math.floor(Math.random() * 4294967296)\n  }, config );\n\n  this._opus_encoder_create = Module._opus_encoder_create;\n  this._opus_encoder_destroy = Module._opus_encoder_destroy;\n  this._opus_encoder_ctl = Module._opus_encoder_ctl;\n  this._speex_resampler_process_interleaved_float = Module._speex_resampler_process_interleaved_float;\n  this._speex_resampler_init = Module._speex_resampler_init;\n  this._speex_resampler_destroy = Module._speex_resampler_destroy;\n  this._opus_encode_float = Module._opus_encode_float;\n  this._free = Module._free;\n  this._malloc = Module._malloc;\n  this.HEAPU8 = Module.HEAPU8;\n  this.HEAP32 = Module.HEAP32;\n  this.HEAPF32 = Module.HEAPF32;\n\n  this.pageIndex = 0;\n  this.granulePosition = 0;\n  this.segmentData = new Uint8Array( 65025 ); // Maximum length of oggOpus data\n  this.segmentDataIndex = 0;\n  this.segmentTable = new Uint8Array( 255 ); // Maximum data segments\n  this.segmentTableIndex = 0;\n  this.framesInPage = 0;\n\n  this.initChecksumTable();\n  this.initCodec();\n  this.initResampler();\n\n  if ( this.config.numberOfChannels === 1 ) {\n    this.interleave = function( buffers ) { return buffers[0]; };\n  }\n};\n\nOggOpusEncoder.prototype.encode = function( buffers ) {\n\n  // Determine bufferLength dynamically\n  if ( !this.bufferLength ) {\n    this.bufferLength = buffers[0].length;\n    this.interleavedBuffers = new Float32Array( this.bufferLength * this.config.numberOfChannels );\n  }\n\n  var samples = this.interleave( buffers );\n  var sampleIndex = 0;\n  var exportPages = [];\n\n  while ( sampleIndex < samples.length ) {\n\n    var lengthToCopy = Math.min( this.resampleBufferLength - this.resampleBufferIndex, samples.length - sampleIndex );\n    this.resampleBuffer.set( samples.subarray( sampleIndex, sampleIndex+lengthToCopy ), this.resampleBufferIndex );\n    sampleIndex += lengthToCopy;\n    this.resampleBufferIndex += lengthToCopy;\n\n    if ( this.resampleBufferIndex === this.resampleBufferLength ) {\n      this._speex_resampler_process_interleaved_float( this.resampler, this.resampleBufferPointer, this.resampleSamplesPerChannelPointer, this.encoderBufferPointer, this.encoderSamplesPerChannelPointer );\n      var packetLength = this._opus_encode_float( this.encoder, this.encoderBufferPointer, this.encoderSamplesPerChannel, this.encoderOutputPointer, this.encoderOutputMaxLength );\n      exportPages.concat(this.segmentPacket( packetLength ));\n      this.resampleBufferIndex = 0;\n\n      this.framesInPage++;\n      if ( this.framesInPage >= this.config.maxFramesPerPage ) {\n        exportPages.push( this.generatePage() );\n      }\n    }\n  }\n\n  return exportPages;\n};\n\nOggOpusEncoder.prototype.destroy = function() {\n  if ( this.encoder ) {\n    this._free(this.encoderSamplesPerChannelPointer);\n    delete this.encoderSamplesPerChannelPointer;\n    this._free(this.encoderBufferPointer);\n    delete this.encoderBufferPointer;\n    this._free(this.encoderOutputPointer);\n    delete this.encoderOutputPointer;\n    this._free(this.resampleSamplesPerChannelPointer);\n    delete this.resampleSamplesPerChannelPointer;\n    this._free(this.resampleBufferPointer);\n    delete this.resampleBufferPointer;\n    this._speex_resampler_destroy(this.resampler);\n    delete this.resampler;\n    this._opus_encoder_destroy(this.encoder);\n    delete this.encoder;\n  }\n};\n\nOggOpusEncoder.prototype.flush = function() {\n  var exportPage;\n  if ( this.framesInPage ) {\n    exportPage = this.generatePage();\n  }\n  // discard any pending data in resample buffer (only a few ms worth)\n  this.resampleBufferIndex = 0;\n  return exportPage;\n};\n\nOggOpusEncoder.prototype.encodeFinalFrame = function() {\n  const exportPages = [];\n\n  // Encode the data remaining in the resample buffer.\n  if ( this.resampleBufferIndex > 0 ) {\n    const dataToFill = (this.resampleBufferLength - this.resampleBufferIndex) / this.config.numberOfChannels;\n    const numBuffers = Math.ceil(dataToFill / this.bufferLength);\n\n    for ( var i = 0; i < numBuffers; i++ ) { \n      var finalFrameBuffers = [];\n      for ( var j = 0; j < this.config.numberOfChannels; j++ ) {\n        finalFrameBuffers.push( new Float32Array( this.bufferLength ));\n      }\n      exportPages.concat(this.encode( finalFrameBuffers ));\n    }\n  }\n\n  this.headerType += 4;\n  exportPages.push(this.generatePage());\n  return exportPages;\n};\n\nOggOpusEncoder.prototype.getChecksum = function( data ){\n  var checksum = 0;\n  for ( var i = 0; i < data.length; i++ ) {\n    checksum = (checksum << 8) ^ this.checksumTable[ ((checksum>>>24) & 0xff) ^ data[i] ];\n  }\n  return checksum >>> 0;\n};\n\nOggOpusEncoder.prototype.generateCommentPage = function(){\n  var segmentDataView = new DataView( this.segmentData.buffer );\n  segmentDataView.setUint32( 0, 1937076303, true ) // Magic Signature 'Opus'\n  segmentDataView.setUint32( 4, 1936154964, true ) // Magic Signature 'Tags'\n  segmentDataView.setUint32( 8, 10, true ); // Vendor Length\n  segmentDataView.setUint32( 12, 1868784978, true ); // Vendor name 'Reco'\n  segmentDataView.setUint32( 16, 1919247474, true ); // Vendor name 'rder'\n  segmentDataView.setUint16( 20, 21322, true ); // Vendor name 'JS'\n  segmentDataView.setUint32( 22, 0, true ); // User Comment List Length\n  this.segmentTableIndex = 1;\n  this.segmentDataIndex = this.segmentTable[0] = 26;\n  this.headerType = 0;\n  return this.generatePage();\n};\n\nOggOpusEncoder.prototype.generateIdPage = function(){\n  var segmentDataView = new DataView( this.segmentData.buffer );\n  segmentDataView.setUint32( 0, 1937076303, true ) // Magic Signature 'Opus'\n  segmentDataView.setUint32( 4, 1684104520, true ) // Magic Signature 'Head'\n  segmentDataView.setUint8( 8, 1, true ); // Version\n  segmentDataView.setUint8( 9, this.config.numberOfChannels, true ); // Channel count\n  segmentDataView.setUint16( 10, 3840, true ); // pre-skip (80ms)\n  segmentDataView.setUint32( 12, this.config.originalSampleRateOverride || this.config.originalSampleRate, true ); // original sample rate\n  segmentDataView.setUint16( 16, 0, true ); // output gain\n  segmentDataView.setUint8( 18, 0, true ); // channel map 0 = mono or stereo\n  this.segmentTableIndex = 1;\n  this.segmentDataIndex = this.segmentTable[0] = 19;\n  this.headerType = 2;\n  return this.generatePage();\n};\n\nOggOpusEncoder.prototype.generatePage = function(){\n  var granulePosition = ( this.lastPositiveGranulePosition === this.granulePosition) ? -1 : this.granulePosition;\n  var pageBuffer = new ArrayBuffer(  27 + this.segmentTableIndex + this.segmentDataIndex );\n  var pageBufferView = new DataView( pageBuffer );\n  var page = new Uint8Array( pageBuffer );\n\n  pageBufferView.setUint32( 0, 1399285583, true); // Capture Pattern starts all page headers 'OggS'\n  pageBufferView.setUint8( 4, 0, true ); // Version\n  pageBufferView.setUint8( 5, this.headerType, true ); // 1 = continuation, 2 = beginning of stream, 4 = end of stream\n\n  // Number of samples upto and including this page at 48000Hz, into signed 64 bit Little Endian integer\n  // Javascript Number maximum value is 53 bits or 2^53 - 1 \n  pageBufferView.setUint32( 6, granulePosition, true );\n  if (granulePosition < 0) {\n    pageBufferView.setInt32( 10, Math.ceil(granulePosition/4294967297) - 1, true );\n  }\n  else {\n    pageBufferView.setInt32( 10, Math.floor(granulePosition/4294967296), true );\n  }\n\n  pageBufferView.setUint32( 14, this.config.serial, true ); // Bitstream serial number\n  pageBufferView.setUint32( 18, this.pageIndex++, true ); // Page sequence number\n  pageBufferView.setUint8( 26, this.segmentTableIndex, true ); // Number of segments in page.\n  page.set( this.segmentTable.subarray(0, this.segmentTableIndex), 27 ); // Segment Table\n  page.set( this.segmentData.subarray(0, this.segmentDataIndex), 27 + this.segmentTableIndex ); // Segment Data\n  pageBufferView.setUint32( 22, this.getChecksum( page ), true ); // Checksum\n\n  var exportPage = { message: 'page', page: page, samplePosition: this.granulePosition };\n  this.segmentTableIndex = 0;\n  this.segmentDataIndex = 0;\n  this.framesInPage = 0;\n  if ( granulePosition > 0 ) {\n    this.lastPositiveGranulePosition = granulePosition;\n  }\n\n  return exportPage;\n};\n\nOggOpusEncoder.prototype.initChecksumTable = function(){\n  this.checksumTable = [];\n  for ( var i = 0; i < 256; i++ ) {\n    var r = i << 24;\n    for ( var j = 0; j < 8; j++ ) {\n      r = ((r & 0x80000000) != 0) ? ((r << 1) ^ 0x04c11db7) : (r << 1);\n    }\n    this.checksumTable[i] = (r & 0xffffffff);\n  }\n};\n\nOggOpusEncoder.prototype.setOpusControl = function( control, value ){\n  var location = this._malloc( 4 );\n  this.HEAP32[ location >> 2 ] = value;\n  this._opus_encoder_ctl( this.encoder, control, location );\n  this._free( location );\n};\n\nOggOpusEncoder.prototype.initCodec = function() {\n  var errLocation = this._malloc( 4 );\n  this.encoder = this._opus_encoder_create( this.config.encoderSampleRate, this.config.numberOfChannels, this.config.encoderApplication, errLocation );\n  this._free( errLocation );\n\n  if ( this.config.encoderBitRate ) {\n    this.setOpusControl( 4002, this.config.encoderBitRate );\n  }\n\n  if ( this.config.encoderComplexity ) {\n    this.setOpusControl( 4010, this.config.encoderComplexity );\n  }\n\n  this.encoderSamplesPerChannel = this.config.encoderSampleRate * this.config.encoderFrameSize / 1000;\n  this.encoderSamplesPerChannelPointer = this._malloc( 4 );\n  this.HEAP32[ this.encoderSamplesPerChannelPointer >> 2 ] = this.encoderSamplesPerChannel;\n\n  this.encoderBufferLength = this.encoderSamplesPerChannel * this.config.numberOfChannels;\n  this.encoderBufferPointer = this._malloc( this.encoderBufferLength * 4 ); // 4 bytes per sample\n  this.encoderBuffer = this.HEAPF32.subarray( this.encoderBufferPointer >> 2, (this.encoderBufferPointer >> 2) + this.encoderBufferLength );\n\n  this.encoderOutputMaxLength = 4000;\n  this.encoderOutputPointer = this._malloc( this.encoderOutputMaxLength );\n  this.encoderOutputBuffer = this.HEAPU8.subarray( this.encoderOutputPointer, this.encoderOutputPointer + this.encoderOutputMaxLength );\n};\n\nOggOpusEncoder.prototype.initResampler = function() {\n  var errLocation = this._malloc( 4 );\n  this.resampler = this._speex_resampler_init( this.config.numberOfChannels, this.config.originalSampleRate, this.config.encoderSampleRate, this.config.resampleQuality, errLocation );\n  this._free( errLocation );\n\n  this.resampleBufferIndex = 0;\n  this.resampleSamplesPerChannel = this.config.originalSampleRate * this.config.encoderFrameSize / 1000;\n  this.resampleSamplesPerChannelPointer = this._malloc( 4 );\n  this.HEAP32[ this.resampleSamplesPerChannelPointer >> 2 ] = this.resampleSamplesPerChannel;\n\n  this.resampleBufferLength = this.resampleSamplesPerChannel * this.config.numberOfChannels;\n  this.resampleBufferPointer = this._malloc( this.resampleBufferLength * 4 ); // 4 bytes per sample\n  this.resampleBuffer = this.HEAPF32.subarray( this.resampleBufferPointer >> 2, (this.resampleBufferPointer >> 2) + this.resampleBufferLength );\n};\n\nOggOpusEncoder.prototype.interleave = function( buffers ) {\n  for ( var i = 0; i < this.bufferLength; i++ ) {\n    for ( var channel = 0; channel < this.config.numberOfChannels; channel++ ) {\n      this.interleavedBuffers[ i * this.config.numberOfChannels + channel ] = buffers[ channel ][ i ];\n    }\n  }\n\n  return this.interleavedBuffers;\n};\n\nOggOpusEncoder.prototype.segmentPacket = function( packetLength ) {\n  var packetIndex = 0;\n  var exportPages = [];\n\n  while ( packetLength >= 0 ) {\n\n    if ( this.segmentTableIndex === 255 ) {\n      exportPages.push( this.generatePage() );\n      this.headerType = 1;\n    }\n\n    var segmentLength = Math.min( packetLength, 255 );\n    this.segmentTable[ this.segmentTableIndex++ ] = segmentLength;\n    this.segmentData.set( this.encoderOutputBuffer.subarray( packetIndex, packetIndex + segmentLength ), this.segmentDataIndex );\n    this.segmentDataIndex += segmentLength;\n    packetIndex += segmentLength;\n    packetLength -= 255;\n  }\n\n  this.granulePosition += ( 48 * this.config.encoderFrameSize );\n  if ( this.segmentTableIndex === 255 ) {\n    exportPages.push( this.generatePage() );\n    this.headerType = 0;\n  }\n\n  return exportPages;\n};\n\n\n// Run in AudioWorkletGlobal scope\nif (global['registerProcessor'] && global['AudioWorkletProcessor']) {\n\n  class EncoderWorklet extends global['AudioWorkletProcessor'] {\n\n    constructor(){\n      super();\n      this.continueProcess = true;\n      this.port.onmessage = ({ data }) => {\n        if (encoder) {\n          switch( data['command'] ){\n\n            case 'getHeaderPages':\n              this.postPage(encoder.generateIdPage());\n              this.postPage(encoder.generateCommentPage());\n              break;\n\n            case 'done':\n              encoder.encodeFinalFrame().forEach(pageData => this.postPage(pageData));\n              this.port.postMessage( {message: 'done'} );\n              break;\n\n            case 'flush':\n              this.postPage(encoder.flush());\n              this.port.postMessage( {message: 'flushed'} );\n              break;\n\n            default:\n              // Ignore any unknown commands and continue recieving commands\n          }\n        }\n\n        switch( data['command'] ){\n\n          case 'close':\n            this.continueProcess = false;\n            break;\n\n          case 'init':\n            if ( encoder ) {\n              encoder.destroy();\n            }\n            encoder = new OggOpusEncoder( data, Module );\n            this.port.postMessage( {message: 'ready'} );\n            break;\n\n          default:\n            // Ignore any unknown commands and continue recieving commands\n        }\n      }\n    }\n\n    process(inputs) {\n      if (encoder && inputs[0]){\n        encoder.encode( inputs[0] ).forEach(pageData => this.postPage(pageData));\n      }\n      return this.continueProcess;\n    }\n\n    postPage(pageData) {\n      if (pageData) {\n        this.port.postMessage( pageData, [pageData.page.buffer] );\n      }\n    }\n  }\n\n  global['registerProcessor']('encoder-worklet', EncoderWorklet);\n}\n\n// run in scriptProcessor worker scope\nelse {\n  var postPageGlobal = (pageData) => {\n    if (pageData) {\n      global['postMessage']( pageData, [pageData.page.buffer] );\n    }\n  }\n\n  global['onmessage'] = ({ data }) => {\n    if (encoder) {\n      switch( data['command'] ){\n\n        case 'encode':\n          encoder.encode( data['buffers'] ).forEach(pageData => postPageGlobal(pageData));\n          break;\n\n        case 'getHeaderPages':\n          postPageGlobal(encoder.generateIdPage());\n          postPageGlobal(encoder.generateCommentPage());\n          break;\n\n        case 'done':\n          encoder.encodeFinalFrame().forEach(pageData => postPageGlobal(pageData));\n          global['postMessage']( {message: 'done'} );\n          break;\n\n        case 'flush':\n          postPageGlobal(encoder.flush());\n          global['postMessage']( {message: 'flushed'} );\n          break;\n\n        default:\n          // Ignore any unknown commands and continue recieving commands\n      }\n    }\n\n    switch( data['command'] ){\n\n      case 'close':\n        global['close']();\n        break;\n\n      case 'init':\n        if ( encoder ) {\n          encoder.destroy();\n        }\n        encoder = new OggOpusEncoder( data, Module, global['postMessage'] );\n        global['postMessage']( {message: 'ready'} );\n        break;\n\n      default:\n        // Ignore any unknown commands and continue recieving commands\n    }\n  };\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZW5jb2Rlcldvcmtlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9lbmNvZGVyV29ya2VyLmpzPzhiM2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBlbmNvZGVyO1xuXG5cbmV4cG9ydCBjb25zdCBFbXNka01vZHVsZSA9IE1vZHVsZTtcbmV4cG9ydCBjb25zdCBPZ2dPcHVzRW5jb2RlciA9IGZ1bmN0aW9uKCBjb25maWcsIE1vZHVsZSApe1xuXG4gIGlmICggIU1vZHVsZSApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01vZHVsZSB3aXRoIGV4cG9ydHMgcmVxdWlyZWQgdG8gaW5pdGlhbGl6ZSBhbiBlbmNvZGVyIGluc3RhbmNlJyk7XG4gIH1cblxuICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oeyBcbiAgICBlbmNvZGVyQXBwbGljYXRpb246IDIwNDksIC8vIDIwNDggPSBWb2ljZSAoTG93ZXIgZmlkZWxpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAyMDQ5ID0gRnVsbCBCYW5kIEF1ZGlvIChIaWdoZXN0IGZpZGVsaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMjA1MSA9IFJlc3RyaWN0ZWQgTG93IERlbGF5IChMb3dlc3QgbGF0ZW5jeSlcbiAgICBlbmNvZGVyRnJhbWVTaXplOiAyMCwgLy8gU3BlY2lmaWVkIGluIG1zLlxuICAgIGVuY29kZXJTYW1wbGVSYXRlOiA0ODAwMCwgLy8gRGVzaXJlZCBlbmNvZGluZyBzYW1wbGUgcmF0ZS4gQXVkaW8gd2lsbCBiZSByZXNhbXBsZWRcbiAgICBtYXhGcmFtZXNQZXJQYWdlOiA0MCwgLy8gVHJhZGVvZmYgbGF0ZW5jeSB3aXRoIG92ZXJoZWFkXG4gICAgbnVtYmVyT2ZDaGFubmVsczogMSxcbiAgICBvcmlnaW5hbFNhbXBsZVJhdGU6IDQ0MTAwLFxuICAgIHJlc2FtcGxlUXVhbGl0eTogMywgLy8gVmFsdWUgYmV0d2VlbiAwIGFuZCAxMCBpbmNsdXNpdmUuIDEwIGJlaW5nIGhpZ2hlc3QgcXVhbGl0eS5cbiAgICBzZXJpYWw6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQyOTQ5NjcyOTYpXG4gIH0sIGNvbmZpZyApO1xuXG4gIHRoaXMuX29wdXNfZW5jb2Rlcl9jcmVhdGUgPSBNb2R1bGUuX29wdXNfZW5jb2Rlcl9jcmVhdGU7XG4gIHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95ID0gTW9kdWxlLl9vcHVzX2VuY29kZXJfZGVzdHJveTtcbiAgdGhpcy5fb3B1c19lbmNvZGVyX2N0bCA9IE1vZHVsZS5fb3B1c19lbmNvZGVyX2N0bDtcbiAgdGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQgPSBNb2R1bGUuX3NwZWV4X3Jlc2FtcGxlcl9wcm9jZXNzX2ludGVybGVhdmVkX2Zsb2F0O1xuICB0aGlzLl9zcGVleF9yZXNhbXBsZXJfaW5pdCA9IE1vZHVsZS5fc3BlZXhfcmVzYW1wbGVyX2luaXQ7XG4gIHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9kZXN0cm95ID0gTW9kdWxlLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveTtcbiAgdGhpcy5fb3B1c19lbmNvZGVfZmxvYXQgPSBNb2R1bGUuX29wdXNfZW5jb2RlX2Zsb2F0O1xuICB0aGlzLl9mcmVlID0gTW9kdWxlLl9mcmVlO1xuICB0aGlzLl9tYWxsb2MgPSBNb2R1bGUuX21hbGxvYztcbiAgdGhpcy5IRUFQVTggPSBNb2R1bGUuSEVBUFU4O1xuICB0aGlzLkhFQVAzMiA9IE1vZHVsZS5IRUFQMzI7XG4gIHRoaXMuSEVBUEYzMiA9IE1vZHVsZS5IRUFQRjMyO1xuXG4gIHRoaXMucGFnZUluZGV4ID0gMDtcbiAgdGhpcy5ncmFudWxlUG9zaXRpb24gPSAwO1xuICB0aGlzLnNlZ21lbnREYXRhID0gbmV3IFVpbnQ4QXJyYXkoIDY1MDI1ICk7IC8vIE1heGltdW0gbGVuZ3RoIG9mIG9nZ09wdXMgZGF0YVxuICB0aGlzLnNlZ21lbnREYXRhSW5kZXggPSAwO1xuICB0aGlzLnNlZ21lbnRUYWJsZSA9IG5ldyBVaW50OEFycmF5KCAyNTUgKTsgLy8gTWF4aW11bSBkYXRhIHNlZ21lbnRzXG4gIHRoaXMuc2VnbWVudFRhYmxlSW5kZXggPSAwO1xuICB0aGlzLmZyYW1lc0luUGFnZSA9IDA7XG5cbiAgdGhpcy5pbml0Q2hlY2tzdW1UYWJsZSgpO1xuICB0aGlzLmluaXRDb2RlYygpO1xuICB0aGlzLmluaXRSZXNhbXBsZXIoKTtcblxuICBpZiAoIHRoaXMuY29uZmlnLm51bWJlck9mQ2hhbm5lbHMgPT09IDEgKSB7XG4gICAgdGhpcy5pbnRlcmxlYXZlID0gZnVuY3Rpb24oIGJ1ZmZlcnMgKSB7IHJldHVybiBidWZmZXJzWzBdOyB9O1xuICB9XG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oIGJ1ZmZlcnMgKSB7XG5cbiAgLy8gRGV0ZXJtaW5lIGJ1ZmZlckxlbmd0aCBkeW5hbWljYWxseVxuICBpZiAoICF0aGlzLmJ1ZmZlckxlbmd0aCApIHtcbiAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IGJ1ZmZlcnNbMF0ubGVuZ3RoO1xuICAgIHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzID0gbmV3IEZsb2F0MzJBcnJheSggdGhpcy5idWZmZXJMZW5ndGggKiB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzICk7XG4gIH1cblxuICB2YXIgc2FtcGxlcyA9IHRoaXMuaW50ZXJsZWF2ZSggYnVmZmVycyApO1xuICB2YXIgc2FtcGxlSW5kZXggPSAwO1xuICB2YXIgZXhwb3J0UGFnZXMgPSBbXTtcblxuICB3aGlsZSAoIHNhbXBsZUluZGV4IDwgc2FtcGxlcy5sZW5ndGggKSB7XG5cbiAgICB2YXIgbGVuZ3RoVG9Db3B5ID0gTWF0aC5taW4oIHRoaXMucmVzYW1wbGVCdWZmZXJMZW5ndGggLSB0aGlzLnJlc2FtcGxlQnVmZmVySW5kZXgsIHNhbXBsZXMubGVuZ3RoIC0gc2FtcGxlSW5kZXggKTtcbiAgICB0aGlzLnJlc2FtcGxlQnVmZmVyLnNldCggc2FtcGxlcy5zdWJhcnJheSggc2FtcGxlSW5kZXgsIHNhbXBsZUluZGV4K2xlbmd0aFRvQ29weSApLCB0aGlzLnJlc2FtcGxlQnVmZmVySW5kZXggKTtcbiAgICBzYW1wbGVJbmRleCArPSBsZW5ndGhUb0NvcHk7XG4gICAgdGhpcy5yZXNhbXBsZUJ1ZmZlckluZGV4ICs9IGxlbmd0aFRvQ29weTtcblxuICAgIGlmICggdGhpcy5yZXNhbXBsZUJ1ZmZlckluZGV4ID09PSB0aGlzLnJlc2FtcGxlQnVmZmVyTGVuZ3RoICkge1xuICAgICAgdGhpcy5fc3BlZXhfcmVzYW1wbGVyX3Byb2Nlc3NfaW50ZXJsZWF2ZWRfZmxvYXQoIHRoaXMucmVzYW1wbGVyLCB0aGlzLnJlc2FtcGxlQnVmZmVyUG9pbnRlciwgdGhpcy5yZXNhbXBsZVNhbXBsZXNQZXJDaGFubmVsUG9pbnRlciwgdGhpcy5lbmNvZGVyQnVmZmVyUG9pbnRlciwgdGhpcy5lbmNvZGVyU2FtcGxlc1BlckNoYW5uZWxQb2ludGVyICk7XG4gICAgICB2YXIgcGFja2V0TGVuZ3RoID0gdGhpcy5fb3B1c19lbmNvZGVfZmxvYXQoIHRoaXMuZW5jb2RlciwgdGhpcy5lbmNvZGVyQnVmZmVyUG9pbnRlciwgdGhpcy5lbmNvZGVyU2FtcGxlc1BlckNoYW5uZWwsIHRoaXMuZW5jb2Rlck91dHB1dFBvaW50ZXIsIHRoaXMuZW5jb2Rlck91dHB1dE1heExlbmd0aCApO1xuICAgICAgZXhwb3J0UGFnZXMuY29uY2F0KHRoaXMuc2VnbWVudFBhY2tldCggcGFja2V0TGVuZ3RoICkpO1xuICAgICAgdGhpcy5yZXNhbXBsZUJ1ZmZlckluZGV4ID0gMDtcblxuICAgICAgdGhpcy5mcmFtZXNJblBhZ2UrKztcbiAgICAgIGlmICggdGhpcy5mcmFtZXNJblBhZ2UgPj0gdGhpcy5jb25maWcubWF4RnJhbWVzUGVyUGFnZSApIHtcbiAgICAgICAgZXhwb3J0UGFnZXMucHVzaCggdGhpcy5nZW5lcmF0ZVBhZ2UoKSApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBleHBvcnRQYWdlcztcbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICggdGhpcy5lbmNvZGVyICkge1xuICAgIHRoaXMuX2ZyZWUodGhpcy5lbmNvZGVyU2FtcGxlc1BlckNoYW5uZWxQb2ludGVyKTtcbiAgICBkZWxldGUgdGhpcy5lbmNvZGVyU2FtcGxlc1BlckNoYW5uZWxQb2ludGVyO1xuICAgIHRoaXMuX2ZyZWUodGhpcy5lbmNvZGVyQnVmZmVyUG9pbnRlcik7XG4gICAgZGVsZXRlIHRoaXMuZW5jb2RlckJ1ZmZlclBvaW50ZXI7XG4gICAgdGhpcy5fZnJlZSh0aGlzLmVuY29kZXJPdXRwdXRQb2ludGVyKTtcbiAgICBkZWxldGUgdGhpcy5lbmNvZGVyT3V0cHV0UG9pbnRlcjtcbiAgICB0aGlzLl9mcmVlKHRoaXMucmVzYW1wbGVTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXIpO1xuICAgIGRlbGV0ZSB0aGlzLnJlc2FtcGxlU2FtcGxlc1BlckNoYW5uZWxQb2ludGVyO1xuICAgIHRoaXMuX2ZyZWUodGhpcy5yZXNhbXBsZUJ1ZmZlclBvaW50ZXIpO1xuICAgIGRlbGV0ZSB0aGlzLnJlc2FtcGxlQnVmZmVyUG9pbnRlcjtcbiAgICB0aGlzLl9zcGVleF9yZXNhbXBsZXJfZGVzdHJveSh0aGlzLnJlc2FtcGxlcik7XG4gICAgZGVsZXRlIHRoaXMucmVzYW1wbGVyO1xuICAgIHRoaXMuX29wdXNfZW5jb2Rlcl9kZXN0cm95KHRoaXMuZW5jb2Rlcik7XG4gICAgZGVsZXRlIHRoaXMuZW5jb2RlcjtcbiAgfVxufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBleHBvcnRQYWdlO1xuICBpZiAoIHRoaXMuZnJhbWVzSW5QYWdlICkge1xuICAgIGV4cG9ydFBhZ2UgPSB0aGlzLmdlbmVyYXRlUGFnZSgpO1xuICB9XG4gIC8vIGRpc2NhcmQgYW55IHBlbmRpbmcgZGF0YSBpbiByZXNhbXBsZSBidWZmZXIgKG9ubHkgYSBmZXcgbXMgd29ydGgpXG4gIHRoaXMucmVzYW1wbGVCdWZmZXJJbmRleCA9IDA7XG4gIHJldHVybiBleHBvcnRQYWdlO1xufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLmVuY29kZUZpbmFsRnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgZXhwb3J0UGFnZXMgPSBbXTtcblxuICAvLyBFbmNvZGUgdGhlIGRhdGEgcmVtYWluaW5nIGluIHRoZSByZXNhbXBsZSBidWZmZXIuXG4gIGlmICggdGhpcy5yZXNhbXBsZUJ1ZmZlckluZGV4ID4gMCApIHtcbiAgICBjb25zdCBkYXRhVG9GaWxsID0gKHRoaXMucmVzYW1wbGVCdWZmZXJMZW5ndGggLSB0aGlzLnJlc2FtcGxlQnVmZmVySW5kZXgpIC8gdGhpcy5jb25maWcubnVtYmVyT2ZDaGFubmVscztcbiAgICBjb25zdCBudW1CdWZmZXJzID0gTWF0aC5jZWlsKGRhdGFUb0ZpbGwgLyB0aGlzLmJ1ZmZlckxlbmd0aCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1CdWZmZXJzOyBpKysgKSB7IFxuICAgICAgdmFyIGZpbmFsRnJhbWVCdWZmZXJzID0gW107XG4gICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzOyBqKysgKSB7XG4gICAgICAgIGZpbmFsRnJhbWVCdWZmZXJzLnB1c2goIG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYnVmZmVyTGVuZ3RoICkpO1xuICAgICAgfVxuICAgICAgZXhwb3J0UGFnZXMuY29uY2F0KHRoaXMuZW5jb2RlKCBmaW5hbEZyYW1lQnVmZmVycyApKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmhlYWRlclR5cGUgKz0gNDtcbiAgZXhwb3J0UGFnZXMucHVzaCh0aGlzLmdlbmVyYXRlUGFnZSgpKTtcbiAgcmV0dXJuIGV4cG9ydFBhZ2VzO1xufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLmdldENoZWNrc3VtID0gZnVuY3Rpb24oIGRhdGEgKXtcbiAgdmFyIGNoZWNrc3VtID0gMDtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKyApIHtcbiAgICBjaGVja3N1bSA9IChjaGVja3N1bSA8PCA4KSBeIHRoaXMuY2hlY2tzdW1UYWJsZVsgKChjaGVja3N1bT4+PjI0KSAmIDB4ZmYpIF4gZGF0YVtpXSBdO1xuICB9XG4gIHJldHVybiBjaGVja3N1bSA+Pj4gMDtcbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5nZW5lcmF0ZUNvbW1lbnRQYWdlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlZ21lbnREYXRhVmlldyA9IG5ldyBEYXRhVmlldyggdGhpcy5zZWdtZW50RGF0YS5idWZmZXIgKTtcbiAgc2VnbWVudERhdGFWaWV3LnNldFVpbnQzMiggMCwgMTkzNzA3NjMwMywgdHJ1ZSApIC8vIE1hZ2ljIFNpZ25hdHVyZSAnT3B1cydcbiAgc2VnbWVudERhdGFWaWV3LnNldFVpbnQzMiggNCwgMTkzNjE1NDk2NCwgdHJ1ZSApIC8vIE1hZ2ljIFNpZ25hdHVyZSAnVGFncydcbiAgc2VnbWVudERhdGFWaWV3LnNldFVpbnQzMiggOCwgMTAsIHRydWUgKTsgLy8gVmVuZG9yIExlbmd0aFxuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDMyKCAxMiwgMTg2ODc4NDk3OCwgdHJ1ZSApOyAvLyBWZW5kb3IgbmFtZSAnUmVjbydcbiAgc2VnbWVudERhdGFWaWV3LnNldFVpbnQzMiggMTYsIDE5MTkyNDc0NzQsIHRydWUgKTsgLy8gVmVuZG9yIG5hbWUgJ3JkZXInXG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50MTYoIDIwLCAyMTMyMiwgdHJ1ZSApOyAvLyBWZW5kb3IgbmFtZSAnSlMnXG4gIHNlZ21lbnREYXRhVmlldy5zZXRVaW50MzIoIDIyLCAwLCB0cnVlICk7IC8vIFVzZXIgQ29tbWVudCBMaXN0IExlbmd0aFxuICB0aGlzLnNlZ21lbnRUYWJsZUluZGV4ID0gMTtcbiAgdGhpcy5zZWdtZW50RGF0YUluZGV4ID0gdGhpcy5zZWdtZW50VGFibGVbMF0gPSAyNjtcbiAgdGhpcy5oZWFkZXJUeXBlID0gMDtcbiAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVQYWdlKCk7XG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuZ2VuZXJhdGVJZFBhZ2UgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VnbWVudERhdGFWaWV3ID0gbmV3IERhdGFWaWV3KCB0aGlzLnNlZ21lbnREYXRhLmJ1ZmZlciApO1xuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDMyKCAwLCAxOTM3MDc2MzAzLCB0cnVlICkgLy8gTWFnaWMgU2lnbmF0dXJlICdPcHVzJ1xuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDMyKCA0LCAxNjg0MTA0NTIwLCB0cnVlICkgLy8gTWFnaWMgU2lnbmF0dXJlICdIZWFkJ1xuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDgoIDgsIDEsIHRydWUgKTsgLy8gVmVyc2lvblxuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDgoIDksIHRoaXMuY29uZmlnLm51bWJlck9mQ2hhbm5lbHMsIHRydWUgKTsgLy8gQ2hhbm5lbCBjb3VudFxuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDE2KCAxMCwgMzg0MCwgdHJ1ZSApOyAvLyBwcmUtc2tpcCAoODBtcylcbiAgc2VnbWVudERhdGFWaWV3LnNldFVpbnQzMiggMTIsIHRoaXMuY29uZmlnLm9yaWdpbmFsU2FtcGxlUmF0ZU92ZXJyaWRlIHx8IHRoaXMuY29uZmlnLm9yaWdpbmFsU2FtcGxlUmF0ZSwgdHJ1ZSApOyAvLyBvcmlnaW5hbCBzYW1wbGUgcmF0ZVxuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDE2KCAxNiwgMCwgdHJ1ZSApOyAvLyBvdXRwdXQgZ2FpblxuICBzZWdtZW50RGF0YVZpZXcuc2V0VWludDgoIDE4LCAwLCB0cnVlICk7IC8vIGNoYW5uZWwgbWFwIDAgPSBtb25vIG9yIHN0ZXJlb1xuICB0aGlzLnNlZ21lbnRUYWJsZUluZGV4ID0gMTtcbiAgdGhpcy5zZWdtZW50RGF0YUluZGV4ID0gdGhpcy5zZWdtZW50VGFibGVbMF0gPSAxOTtcbiAgdGhpcy5oZWFkZXJUeXBlID0gMjtcbiAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVQYWdlKCk7XG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuZ2VuZXJhdGVQYWdlID0gZnVuY3Rpb24oKXtcbiAgdmFyIGdyYW51bGVQb3NpdGlvbiA9ICggdGhpcy5sYXN0UG9zaXRpdmVHcmFudWxlUG9zaXRpb24gPT09IHRoaXMuZ3JhbnVsZVBvc2l0aW9uKSA/IC0xIDogdGhpcy5ncmFudWxlUG9zaXRpb247XG4gIHZhciBwYWdlQnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKCAgMjcgKyB0aGlzLnNlZ21lbnRUYWJsZUluZGV4ICsgdGhpcy5zZWdtZW50RGF0YUluZGV4ICk7XG4gIHZhciBwYWdlQnVmZmVyVmlldyA9IG5ldyBEYXRhVmlldyggcGFnZUJ1ZmZlciApO1xuICB2YXIgcGFnZSA9IG5ldyBVaW50OEFycmF5KCBwYWdlQnVmZmVyICk7XG5cbiAgcGFnZUJ1ZmZlclZpZXcuc2V0VWludDMyKCAwLCAxMzk5Mjg1NTgzLCB0cnVlKTsgLy8gQ2FwdHVyZSBQYXR0ZXJuIHN0YXJ0cyBhbGwgcGFnZSBoZWFkZXJzICdPZ2dTJ1xuICBwYWdlQnVmZmVyVmlldy5zZXRVaW50OCggNCwgMCwgdHJ1ZSApOyAvLyBWZXJzaW9uXG4gIHBhZ2VCdWZmZXJWaWV3LnNldFVpbnQ4KCA1LCB0aGlzLmhlYWRlclR5cGUsIHRydWUgKTsgLy8gMSA9IGNvbnRpbnVhdGlvbiwgMiA9IGJlZ2lubmluZyBvZiBzdHJlYW0sIDQgPSBlbmQgb2Ygc3RyZWFtXG5cbiAgLy8gTnVtYmVyIG9mIHNhbXBsZXMgdXB0byBhbmQgaW5jbHVkaW5nIHRoaXMgcGFnZSBhdCA0ODAwMEh6LCBpbnRvIHNpZ25lZCA2NCBiaXQgTGl0dGxlIEVuZGlhbiBpbnRlZ2VyXG4gIC8vIEphdmFzY3JpcHQgTnVtYmVyIG1heGltdW0gdmFsdWUgaXMgNTMgYml0cyBvciAyXjUzIC0gMSBcbiAgcGFnZUJ1ZmZlclZpZXcuc2V0VWludDMyKCA2LCBncmFudWxlUG9zaXRpb24sIHRydWUgKTtcbiAgaWYgKGdyYW51bGVQb3NpdGlvbiA8IDApIHtcbiAgICBwYWdlQnVmZmVyVmlldy5zZXRJbnQzMiggMTAsIE1hdGguY2VpbChncmFudWxlUG9zaXRpb24vNDI5NDk2NzI5NykgLSAxLCB0cnVlICk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcGFnZUJ1ZmZlclZpZXcuc2V0SW50MzIoIDEwLCBNYXRoLmZsb29yKGdyYW51bGVQb3NpdGlvbi80Mjk0OTY3Mjk2KSwgdHJ1ZSApO1xuICB9XG5cbiAgcGFnZUJ1ZmZlclZpZXcuc2V0VWludDMyKCAxNCwgdGhpcy5jb25maWcuc2VyaWFsLCB0cnVlICk7IC8vIEJpdHN0cmVhbSBzZXJpYWwgbnVtYmVyXG4gIHBhZ2VCdWZmZXJWaWV3LnNldFVpbnQzMiggMTgsIHRoaXMucGFnZUluZGV4KyssIHRydWUgKTsgLy8gUGFnZSBzZXF1ZW5jZSBudW1iZXJcbiAgcGFnZUJ1ZmZlclZpZXcuc2V0VWludDgoIDI2LCB0aGlzLnNlZ21lbnRUYWJsZUluZGV4LCB0cnVlICk7IC8vIE51bWJlciBvZiBzZWdtZW50cyBpbiBwYWdlLlxuICBwYWdlLnNldCggdGhpcy5zZWdtZW50VGFibGUuc3ViYXJyYXkoMCwgdGhpcy5zZWdtZW50VGFibGVJbmRleCksIDI3ICk7IC8vIFNlZ21lbnQgVGFibGVcbiAgcGFnZS5zZXQoIHRoaXMuc2VnbWVudERhdGEuc3ViYXJyYXkoMCwgdGhpcy5zZWdtZW50RGF0YUluZGV4KSwgMjcgKyB0aGlzLnNlZ21lbnRUYWJsZUluZGV4ICk7IC8vIFNlZ21lbnQgRGF0YVxuICBwYWdlQnVmZmVyVmlldy5zZXRVaW50MzIoIDIyLCB0aGlzLmdldENoZWNrc3VtKCBwYWdlICksIHRydWUgKTsgLy8gQ2hlY2tzdW1cblxuICB2YXIgZXhwb3J0UGFnZSA9IHsgbWVzc2FnZTogJ3BhZ2UnLCBwYWdlOiBwYWdlLCBzYW1wbGVQb3NpdGlvbjogdGhpcy5ncmFudWxlUG9zaXRpb24gfTtcbiAgdGhpcy5zZWdtZW50VGFibGVJbmRleCA9IDA7XG4gIHRoaXMuc2VnbWVudERhdGFJbmRleCA9IDA7XG4gIHRoaXMuZnJhbWVzSW5QYWdlID0gMDtcbiAgaWYgKCBncmFudWxlUG9zaXRpb24gPiAwICkge1xuICAgIHRoaXMubGFzdFBvc2l0aXZlR3JhbnVsZVBvc2l0aW9uID0gZ3JhbnVsZVBvc2l0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydFBhZ2U7XG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuaW5pdENoZWNrc3VtVGFibGUgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNoZWNrc3VtVGFibGUgPSBbXTtcbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgMjU2OyBpKysgKSB7XG4gICAgdmFyIHIgPSBpIDw8IDI0O1xuICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDg7IGorKyApIHtcbiAgICAgIHIgPSAoKHIgJiAweDgwMDAwMDAwKSAhPSAwKSA/ICgociA8PCAxKSBeIDB4MDRjMTFkYjcpIDogKHIgPDwgMSk7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tzdW1UYWJsZVtpXSA9IChyICYgMHhmZmZmZmZmZik7XG4gIH1cbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5zZXRPcHVzQ29udHJvbCA9IGZ1bmN0aW9uKCBjb250cm9sLCB2YWx1ZSApe1xuICB2YXIgbG9jYXRpb24gPSB0aGlzLl9tYWxsb2MoIDQgKTtcbiAgdGhpcy5IRUFQMzJbIGxvY2F0aW9uID4+IDIgXSA9IHZhbHVlO1xuICB0aGlzLl9vcHVzX2VuY29kZXJfY3RsKCB0aGlzLmVuY29kZXIsIGNvbnRyb2wsIGxvY2F0aW9uICk7XG4gIHRoaXMuX2ZyZWUoIGxvY2F0aW9uICk7XG59O1xuXG5PZ2dPcHVzRW5jb2Rlci5wcm90b3R5cGUuaW5pdENvZGVjID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlcnJMb2NhdGlvbiA9IHRoaXMuX21hbGxvYyggNCApO1xuICB0aGlzLmVuY29kZXIgPSB0aGlzLl9vcHVzX2VuY29kZXJfY3JlYXRlKCB0aGlzLmNvbmZpZy5lbmNvZGVyU2FtcGxlUmF0ZSwgdGhpcy5jb25maWcubnVtYmVyT2ZDaGFubmVscywgdGhpcy5jb25maWcuZW5jb2RlckFwcGxpY2F0aW9uLCBlcnJMb2NhdGlvbiApO1xuICB0aGlzLl9mcmVlKCBlcnJMb2NhdGlvbiApO1xuXG4gIGlmICggdGhpcy5jb25maWcuZW5jb2RlckJpdFJhdGUgKSB7XG4gICAgdGhpcy5zZXRPcHVzQ29udHJvbCggNDAwMiwgdGhpcy5jb25maWcuZW5jb2RlckJpdFJhdGUgKTtcbiAgfVxuXG4gIGlmICggdGhpcy5jb25maWcuZW5jb2RlckNvbXBsZXhpdHkgKSB7XG4gICAgdGhpcy5zZXRPcHVzQ29udHJvbCggNDAxMCwgdGhpcy5jb25maWcuZW5jb2RlckNvbXBsZXhpdHkgKTtcbiAgfVxuXG4gIHRoaXMuZW5jb2RlclNhbXBsZXNQZXJDaGFubmVsID0gdGhpcy5jb25maWcuZW5jb2RlclNhbXBsZVJhdGUgKiB0aGlzLmNvbmZpZy5lbmNvZGVyRnJhbWVTaXplIC8gMTAwMDtcbiAgdGhpcy5lbmNvZGVyU2FtcGxlc1BlckNoYW5uZWxQb2ludGVyID0gdGhpcy5fbWFsbG9jKCA0ICk7XG4gIHRoaXMuSEVBUDMyWyB0aGlzLmVuY29kZXJTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXIgPj4gMiBdID0gdGhpcy5lbmNvZGVyU2FtcGxlc1BlckNoYW5uZWw7XG5cbiAgdGhpcy5lbmNvZGVyQnVmZmVyTGVuZ3RoID0gdGhpcy5lbmNvZGVyU2FtcGxlc1BlckNoYW5uZWwgKiB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzO1xuICB0aGlzLmVuY29kZXJCdWZmZXJQb2ludGVyID0gdGhpcy5fbWFsbG9jKCB0aGlzLmVuY29kZXJCdWZmZXJMZW5ndGggKiA0ICk7IC8vIDQgYnl0ZXMgcGVyIHNhbXBsZVxuICB0aGlzLmVuY29kZXJCdWZmZXIgPSB0aGlzLkhFQVBGMzIuc3ViYXJyYXkoIHRoaXMuZW5jb2RlckJ1ZmZlclBvaW50ZXIgPj4gMiwgKHRoaXMuZW5jb2RlckJ1ZmZlclBvaW50ZXIgPj4gMikgKyB0aGlzLmVuY29kZXJCdWZmZXJMZW5ndGggKTtcblxuICB0aGlzLmVuY29kZXJPdXRwdXRNYXhMZW5ndGggPSA0MDAwO1xuICB0aGlzLmVuY29kZXJPdXRwdXRQb2ludGVyID0gdGhpcy5fbWFsbG9jKCB0aGlzLmVuY29kZXJPdXRwdXRNYXhMZW5ndGggKTtcbiAgdGhpcy5lbmNvZGVyT3V0cHV0QnVmZmVyID0gdGhpcy5IRUFQVTguc3ViYXJyYXkoIHRoaXMuZW5jb2Rlck91dHB1dFBvaW50ZXIsIHRoaXMuZW5jb2Rlck91dHB1dFBvaW50ZXIgKyB0aGlzLmVuY29kZXJPdXRwdXRNYXhMZW5ndGggKTtcbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5pbml0UmVzYW1wbGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlcnJMb2NhdGlvbiA9IHRoaXMuX21hbGxvYyggNCApO1xuICB0aGlzLnJlc2FtcGxlciA9IHRoaXMuX3NwZWV4X3Jlc2FtcGxlcl9pbml0KCB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzLCB0aGlzLmNvbmZpZy5vcmlnaW5hbFNhbXBsZVJhdGUsIHRoaXMuY29uZmlnLmVuY29kZXJTYW1wbGVSYXRlLCB0aGlzLmNvbmZpZy5yZXNhbXBsZVF1YWxpdHksIGVyckxvY2F0aW9uICk7XG4gIHRoaXMuX2ZyZWUoIGVyckxvY2F0aW9uICk7XG5cbiAgdGhpcy5yZXNhbXBsZUJ1ZmZlckluZGV4ID0gMDtcbiAgdGhpcy5yZXNhbXBsZVNhbXBsZXNQZXJDaGFubmVsID0gdGhpcy5jb25maWcub3JpZ2luYWxTYW1wbGVSYXRlICogdGhpcy5jb25maWcuZW5jb2RlckZyYW1lU2l6ZSAvIDEwMDA7XG4gIHRoaXMucmVzYW1wbGVTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXIgPSB0aGlzLl9tYWxsb2MoIDQgKTtcbiAgdGhpcy5IRUFQMzJbIHRoaXMucmVzYW1wbGVTYW1wbGVzUGVyQ2hhbm5lbFBvaW50ZXIgPj4gMiBdID0gdGhpcy5yZXNhbXBsZVNhbXBsZXNQZXJDaGFubmVsO1xuXG4gIHRoaXMucmVzYW1wbGVCdWZmZXJMZW5ndGggPSB0aGlzLnJlc2FtcGxlU2FtcGxlc1BlckNoYW5uZWwgKiB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzO1xuICB0aGlzLnJlc2FtcGxlQnVmZmVyUG9pbnRlciA9IHRoaXMuX21hbGxvYyggdGhpcy5yZXNhbXBsZUJ1ZmZlckxlbmd0aCAqIDQgKTsgLy8gNCBieXRlcyBwZXIgc2FtcGxlXG4gIHRoaXMucmVzYW1wbGVCdWZmZXIgPSB0aGlzLkhFQVBGMzIuc3ViYXJyYXkoIHRoaXMucmVzYW1wbGVCdWZmZXJQb2ludGVyID4+IDIsICh0aGlzLnJlc2FtcGxlQnVmZmVyUG9pbnRlciA+PiAyKSArIHRoaXMucmVzYW1wbGVCdWZmZXJMZW5ndGggKTtcbn07XG5cbk9nZ09wdXNFbmNvZGVyLnByb3RvdHlwZS5pbnRlcmxlYXZlID0gZnVuY3Rpb24oIGJ1ZmZlcnMgKSB7XG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVyTGVuZ3RoOyBpKysgKSB7XG4gICAgZm9yICggdmFyIGNoYW5uZWwgPSAwOyBjaGFubmVsIDwgdGhpcy5jb25maWcubnVtYmVyT2ZDaGFubmVsczsgY2hhbm5lbCsrICkge1xuICAgICAgdGhpcy5pbnRlcmxlYXZlZEJ1ZmZlcnNbIGkgKiB0aGlzLmNvbmZpZy5udW1iZXJPZkNoYW5uZWxzICsgY2hhbm5lbCBdID0gYnVmZmVyc1sgY2hhbm5lbCBdWyBpIF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuaW50ZXJsZWF2ZWRCdWZmZXJzO1xufTtcblxuT2dnT3B1c0VuY29kZXIucHJvdG90eXBlLnNlZ21lbnRQYWNrZXQgPSBmdW5jdGlvbiggcGFja2V0TGVuZ3RoICkge1xuICB2YXIgcGFja2V0SW5kZXggPSAwO1xuICB2YXIgZXhwb3J0UGFnZXMgPSBbXTtcblxuICB3aGlsZSAoIHBhY2tldExlbmd0aCA+PSAwICkge1xuXG4gICAgaWYgKCB0aGlzLnNlZ21lbnRUYWJsZUluZGV4ID09PSAyNTUgKSB7XG4gICAgICBleHBvcnRQYWdlcy5wdXNoKCB0aGlzLmdlbmVyYXRlUGFnZSgpICk7XG4gICAgICB0aGlzLmhlYWRlclR5cGUgPSAxO1xuICAgIH1cblxuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gTWF0aC5taW4oIHBhY2tldExlbmd0aCwgMjU1ICk7XG4gICAgdGhpcy5zZWdtZW50VGFibGVbIHRoaXMuc2VnbWVudFRhYmxlSW5kZXgrKyBdID0gc2VnbWVudExlbmd0aDtcbiAgICB0aGlzLnNlZ21lbnREYXRhLnNldCggdGhpcy5lbmNvZGVyT3V0cHV0QnVmZmVyLnN1YmFycmF5KCBwYWNrZXRJbmRleCwgcGFja2V0SW5kZXggKyBzZWdtZW50TGVuZ3RoICksIHRoaXMuc2VnbWVudERhdGFJbmRleCApO1xuICAgIHRoaXMuc2VnbWVudERhdGFJbmRleCArPSBzZWdtZW50TGVuZ3RoO1xuICAgIHBhY2tldEluZGV4ICs9IHNlZ21lbnRMZW5ndGg7XG4gICAgcGFja2V0TGVuZ3RoIC09IDI1NTtcbiAgfVxuXG4gIHRoaXMuZ3JhbnVsZVBvc2l0aW9uICs9ICggNDggKiB0aGlzLmNvbmZpZy5lbmNvZGVyRnJhbWVTaXplICk7XG4gIGlmICggdGhpcy5zZWdtZW50VGFibGVJbmRleCA9PT0gMjU1ICkge1xuICAgIGV4cG9ydFBhZ2VzLnB1c2goIHRoaXMuZ2VuZXJhdGVQYWdlKCkgKTtcbiAgICB0aGlzLmhlYWRlclR5cGUgPSAwO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydFBhZ2VzO1xufTtcblxuXG4vLyBSdW4gaW4gQXVkaW9Xb3JrbGV0R2xvYmFsIHNjb3BlXG5pZiAoZ2xvYmFsWydyZWdpc3RlclByb2Nlc3NvciddICYmIGdsb2JhbFsnQXVkaW9Xb3JrbGV0UHJvY2Vzc29yJ10pIHtcblxuICBjbGFzcyBFbmNvZGVyV29ya2xldCBleHRlbmRzIGdsb2JhbFsnQXVkaW9Xb3JrbGV0UHJvY2Vzc29yJ10ge1xuXG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLmNvbnRpbnVlUHJvY2VzcyA9IHRydWU7XG4gICAgICB0aGlzLnBvcnQub25tZXNzYWdlID0gKHsgZGF0YSB9KSA9PiB7XG4gICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgc3dpdGNoKCBkYXRhWydjb21tYW5kJ10gKXtcblxuICAgICAgICAgICAgY2FzZSAnZ2V0SGVhZGVyUGFnZXMnOlxuICAgICAgICAgICAgICB0aGlzLnBvc3RQYWdlKGVuY29kZXIuZ2VuZXJhdGVJZFBhZ2UoKSk7XG4gICAgICAgICAgICAgIHRoaXMucG9zdFBhZ2UoZW5jb2Rlci5nZW5lcmF0ZUNvbW1lbnRQYWdlKCkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgICAgIGVuY29kZXIuZW5jb2RlRmluYWxGcmFtZSgpLmZvckVhY2gocGFnZURhdGEgPT4gdGhpcy5wb3N0UGFnZShwYWdlRGF0YSkpO1xuICAgICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UoIHttZXNzYWdlOiAnZG9uZSd9ICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgICAgICAgIHRoaXMucG9zdFBhZ2UoZW5jb2Rlci5mbHVzaCgpKTtcbiAgICAgICAgICAgICAgdGhpcy5wb3J0LnBvc3RNZXNzYWdlKCB7bWVzc2FnZTogJ2ZsdXNoZWQnfSApO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gSWdub3JlIGFueSB1bmtub3duIGNvbW1hbmRzIGFuZCBjb250aW51ZSByZWNpZXZpbmcgY29tbWFuZHNcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2goIGRhdGFbJ2NvbW1hbmQnXSApe1xuXG4gICAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgICAgdGhpcy5jb250aW51ZVByb2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaW5pdCc6XG4gICAgICAgICAgICBpZiAoIGVuY29kZXIgKSB7XG4gICAgICAgICAgICAgIGVuY29kZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5jb2RlciA9IG5ldyBPZ2dPcHVzRW5jb2RlciggZGF0YSwgTW9kdWxlICk7XG4gICAgICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UoIHttZXNzYWdlOiAncmVhZHknfSApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gSWdub3JlIGFueSB1bmtub3duIGNvbW1hbmRzIGFuZCBjb250aW51ZSByZWNpZXZpbmcgY29tbWFuZHNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHByb2Nlc3MoaW5wdXRzKSB7XG4gICAgICBpZiAoZW5jb2RlciAmJiBpbnB1dHNbMF0pe1xuICAgICAgICBlbmNvZGVyLmVuY29kZSggaW5wdXRzWzBdICkuZm9yRWFjaChwYWdlRGF0YSA9PiB0aGlzLnBvc3RQYWdlKHBhZ2VEYXRhKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jb250aW51ZVByb2Nlc3M7XG4gICAgfVxuXG4gICAgcG9zdFBhZ2UocGFnZURhdGEpIHtcbiAgICAgIGlmIChwYWdlRGF0YSkge1xuICAgICAgICB0aGlzLnBvcnQucG9zdE1lc3NhZ2UoIHBhZ2VEYXRhLCBbcGFnZURhdGEucGFnZS5idWZmZXJdICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsWydyZWdpc3RlclByb2Nlc3NvciddKCdlbmNvZGVyLXdvcmtsZXQnLCBFbmNvZGVyV29ya2xldCk7XG59XG5cbi8vIHJ1biBpbiBzY3JpcHRQcm9jZXNzb3Igd29ya2VyIHNjb3BlXG5lbHNlIHtcbiAgdmFyIHBvc3RQYWdlR2xvYmFsID0gKHBhZ2VEYXRhKSA9PiB7XG4gICAgaWYgKHBhZ2VEYXRhKSB7XG4gICAgICBnbG9iYWxbJ3Bvc3RNZXNzYWdlJ10oIHBhZ2VEYXRhLCBbcGFnZURhdGEucGFnZS5idWZmZXJdICk7XG4gICAgfVxuICB9XG5cbiAgZ2xvYmFsWydvbm1lc3NhZ2UnXSA9ICh7IGRhdGEgfSkgPT4ge1xuICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICBzd2l0Y2goIGRhdGFbJ2NvbW1hbmQnXSApe1xuXG4gICAgICAgIGNhc2UgJ2VuY29kZSc6XG4gICAgICAgICAgZW5jb2Rlci5lbmNvZGUoIGRhdGFbJ2J1ZmZlcnMnXSApLmZvckVhY2gocGFnZURhdGEgPT4gcG9zdFBhZ2VHbG9iYWwocGFnZURhdGEpKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdnZXRIZWFkZXJQYWdlcyc6XG4gICAgICAgICAgcG9zdFBhZ2VHbG9iYWwoZW5jb2Rlci5nZW5lcmF0ZUlkUGFnZSgpKTtcbiAgICAgICAgICBwb3N0UGFnZUdsb2JhbChlbmNvZGVyLmdlbmVyYXRlQ29tbWVudFBhZ2UoKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZG9uZSc6XG4gICAgICAgICAgZW5jb2Rlci5lbmNvZGVGaW5hbEZyYW1lKCkuZm9yRWFjaChwYWdlRGF0YSA9PiBwb3N0UGFnZUdsb2JhbChwYWdlRGF0YSkpO1xuICAgICAgICAgIGdsb2JhbFsncG9zdE1lc3NhZ2UnXSgge21lc3NhZ2U6ICdkb25lJ30gKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmbHVzaCc6XG4gICAgICAgICAgcG9zdFBhZ2VHbG9iYWwoZW5jb2Rlci5mbHVzaCgpKTtcbiAgICAgICAgICBnbG9iYWxbJ3Bvc3RNZXNzYWdlJ10oIHttZXNzYWdlOiAnZmx1c2hlZCd9ICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBJZ25vcmUgYW55IHVua25vd24gY29tbWFuZHMgYW5kIGNvbnRpbnVlIHJlY2lldmluZyBjb21tYW5kc1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCggZGF0YVsnY29tbWFuZCddICl7XG5cbiAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgICAgZ2xvYmFsWydjbG9zZSddKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgaWYgKCBlbmNvZGVyICkge1xuICAgICAgICAgIGVuY29kZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZXIgPSBuZXcgT2dnT3B1c0VuY29kZXIoIGRhdGEsIE1vZHVsZSwgZ2xvYmFsWydwb3N0TWVzc2FnZSddICk7XG4gICAgICAgIGdsb2JhbFsncG9zdE1lc3NhZ2UnXSgge21lc3NhZ2U6ICdyZWFkeSd9ICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJZ25vcmUgYW55IHVua25vd24gY29tbWFuZHMgYW5kIGNvbnRpbnVlIHJlY2lldmluZyBjb21tYW5kc1xuICAgIH1cbiAgfTtcbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/encoderWorker.js\n");
>>>>>>> bufferMismatch

/***/ })

/******/ });
});